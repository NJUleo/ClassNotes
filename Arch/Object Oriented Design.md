## Object Oriented Design

#### where does OOD fit?

已经分析好的系统架构，由各种交互方式。

在问题域中间找到要实现的类。

OOA -> OOD -> OOP 对问题域对象的分析到具体设计，到代码实现

算法相互明确没有循环调用，重构

异构数据处理，添加额外类

动态调整

#### Finding Appropriate Object

找到恰当的对象完成OOD。

把system分解为不同的对象

一些类来自于系统架构，还有一些来自于代码实现架构所需要的

功能性的类

比如为了继承、封装。

把具体问题的设计进行淡化，更好的复用

使用模式

#### 问题

没有直接方法从OOA到OOD

经验

不断重构、不断面对需求变更，获得的经验

每次相似问题，拿到原来的设计

### 面向对象设计原则

#### 概述

可维护性、可拓展性、可复用性。

**可维护的复用**

通常来说相同的目标，但是也有抵触。

僵硬、脆弱、复用性低、黏度过高

僵硬：新功能要较大改动。弹性

以对象作为复用单位

通过信息隐藏正确性

##### 好的软件设计：

可拓展性：新功能加入，不需要太大的成本。对应僵硬

灵活性：修改时不会设计很多其他模块，改动灵活。对应脆弱。改动局限在某个模块

可插入性：方便的将模块抽取并替换。对应黏度过高

##### 可维护性和可复用性

很多情况下，复用破坏可维护性。

希望是添加而不是更改。

原则反复相互映衬，地位也不同。

#### 单一职责原则

##### 定义

一个对象只安排一个职责，并完整封装在一个类。

一个类只有一个引起它变化的原因。（职责的变化）

##### 分析

一个类职责越多，被复用的可能性就越少。

职责相互耦合，一个变化影响其它的。

职责包括数据职责和行为职责，分别由属性和方法体现。

职责过多就很脆弱，相互影响

不同的职责的封装等于对变更的封装。

实现高内聚低耦合的指导方针。

控制类的粒度变小

改动的可能降低，仅因为一个职责变化而发生改动。

哪些算单一职责？随着问题域变化。

##### 例子

类是一个复用的粒度（方法都被封装在一起）

login

入口、显示、连接数据库都在一起。

对数据库增删改查，DAO

数据库连接 Util

显示

函数入口

拆分成粒度适当的类，按照职责进行。比如，增删改查在一起。避免每次依赖太多的小类。

#### 开闭原则

最重要的原则

##### 定义

对修改关闭，对扩展开放

实现不修改源代码的情况下，改变模块的行为。加一些其他的类或方法改变类的行为。

复用的一追求就是不改变源代码。

##### 分析

Object-Oriented Software Construction, by Bertrand Meyer

最重要的原则。

需求总在变化

**抽象化是实现开闭原则的关键**。

通过抽象类、接口，实现相对稳定的抽象层，把变化的内容封装在具体的实现当中。依赖于抽象层的其他模块，不需要改动，这些模块对修改关闭。添加新的满足抽象类，实现。

面向对象的继承和多态往往不是为了复用，这种复用是静态、死板的。往往是作为一种抽象。

找到确定的地方，作为抽象，变化的放在一起。

##### EVP

对可变性的封装

把系统的可变因素找到并封装

##### 例子

分析，找到变与不变的部分，把变化的部分抽象、隔离，进行封装，为变化的部分实现抽象层而不影响不变的部分。

new的时候总是要由具体的。作为一种变化，也可以分离抽象，工厂模式，将创建进行封装。或者，通过反射机制，写在配置文件中。

#### 里氏代换原则

开闭原则进行抽象，具体代码中由变化的子类。

父类和子类的关系要满足LSP

##### 定义

所有使用父类的地方替换成子类，要求原程序**行为**没有变化。

引用父类的地方必须能够透明地使用子类对象。

##### 分析

期望性质不变。子类替换父类，子类前置条件更弱，后置条件更强。

子类必须实现父类的所有方法。

子类的额外方法，作为私有的。额外的方法可能导致其他模块依赖于这个具体的子类，而不能被替换。

尽量把父类变成抽象类或者接口。子类不能有公开的额外的方法。

不依赖于具体的子类。

不希望子类扩展行为，而是希望实现父类方法中可能的变化行为。

##### 例子

根据开闭原则，分离加密算法并进行抽象。

再根据里氏代换原则

#### Dependence Inversion Principle 依赖倒转原则

开闭原则要求抽象化

DIP决定抽象化

##### 定义

高层模块不应该依赖底层模块，而是他们都依赖抽象。抽象不应该依赖与细节，细节依赖于抽象。

针对接口编程

##### 分析

以前一般认为，单向的依赖，高层依赖底层就行。在DIP当中，具体代码的依赖不能满足弹性。

高层代码使用抽象接口，低层细节根据抽象的规约实现接口。

接口可以是抽象类，可以是interface

具体来说，就是使用传递参数、对象组合、对象返回值的时候，用类的抽象类型而不是具体类型。

推迟对具体类的定义。延迟到真正使用的时候，通过读取元数据（如配置文件），在运行时确定到底需要什么具体类。让系统具有更好的灵活性，修改配置文件而不修改源代码。

###### 类之间的耦合

1. 零耦合

完全没有任何关系，实际上是不存在的。

2. 具体耦合

两个类都是具体类,直接依赖。一个类的关系必定影响另一个

3. 抽象耦合

未必是两个抽象类（工厂模式就是两个抽象类）

只要是一个类是具体类

###### 依赖注入与控制反转

DI IoC

通过容器查找注入的依赖对象，客户端本身不直接创建（而产生依赖）。是对工厂模式的一种提升，利用JAVA反射机制动态创建对象并注入。对象只是被动得接受依赖对象而不是主动去创建。

由此实现DIP，因为创建具体对象得过程也不在源代码中，而是通过容器读取配置文件之后动态创建并注入客户端中。

* 构造注入 通过构造函数注入实例变量
* 设值注入 通过Setter方法注入
* 接口注入 通过接口方法注入

##### 实例

针对抽象编程，具体类的定义放在配置文件中。

具体放在元数据，抽象放在代码

#### 接口隔离原则

ISP

接口需要满足的要求

##### 定义

客户端不应该依赖它不需要的接口。

接口太大的时候，需要将它分割为更小的接口。

##### 分析

多个专门接口而不是一个大的总接口

每一个接口承担一个相对独立的职责。

对客户端隐藏不需要的行为

逻辑角色，“角色隔离原则”，在这一点上，和单一职责是统一的。

接口的隔离，灵活性。

分离接口的时候，实现单一职责原则进行拆分

满足**高内聚**的前提下（拆得太细也不好）

通过对不同客户端提供宽窄不同得接口实现封装。

通过限制接口大小实现信息隐藏

#### 合成复用原则

合成表示组合和聚合

全局和局部的生命周期

##### 定义

尽量使用对象合成而不是继承，来达到**复用**的目的

##### 分析

合成复用：新的对象通过关联关系来使用一些已经有的对象，使其成为新对象的一部分。复用被组合功能的对象的方法。通过委派调用已有对象的方法达到复用。

继承破坏基类的封装性，将其实现细节暴露给子类。这是一种白箱复用。静态的，不能在运行时发生改变，灵活性很差。基类改动之后，子类全部要改。继承的维护的成本过高。

组合/聚合复用：耦合性低，选择性、动态调用成员对象。黑箱复用。

如果直接复用，组合好一些；添加行为、更改行为，组合的情况是有约束条件，只有通过修改前置后置才行，但是如果要改写基类的是只能通过继承。

首先考虑组合，一定要使用继承，就考虑Liskov。慎重使用继承复用

合成复用的边界

继承复用的是抽象部分，类定义

合成复用的时候，委托一个类进行，是复用的类实现。

并不是和继承矛盾的。合成复用和依赖倒转结合的。耦合的是抽象，通过抽象类的多态实现复用。引用的仍然是抽象类型。

反对的是通过继承使用基类代码，而不是反对抽象类。

##### 实例

#### 迪米特法则

LoD

最少知识原则

##### 定义

不要和陌生人说话

只和直接的朋友通信

（消息传递和方法调用）

只调用直接朋友的方法

每一个软件的单位对其他的单位都只有最少的知识，而且局限于与本单位密切相关的软件单位。

###### 直接朋友：

this

参数形式传递来的对象

成员对象

当前对象的成员对象是一个集合，则其中的元素也是

当前对象创建的对象

###### 陌生人

可能接触到却不是直接朋友？

直接朋友方法返回的对象

##### 分析

松耦合的类

依赖倒转也体现了LoD

访问权限体现了接口最小原则

控制信息的宽度和深度

不要直接依赖的数目，提供比较小的接口

###### 狭义的迪米特法则

相当于，与朋友的成员变量产生了耦合，这一个耦合链将非常长

chain的调用。

实际上是需要将中间的类，进行封装，对调用者进行信息隐藏

通信效率低了，因为需要大量的小方法进行调用，不过降低了类之间的耦合。

通常可维护性都和效率矛盾。

###### 广义

##### 实例

引入控制类，不存在

#### 思考

Stack 继承 Vector

子类基类的接口

违反合成复用原则，继承了更多的、不需要的接口。实际上应该用合成





