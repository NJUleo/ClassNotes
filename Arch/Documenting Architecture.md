# Documenting Architecture

##### 上节课ADD

element 是什么 相互关系

架构之后，进行文档化

### 为什么进行架构文档

##### 沟通的一个媒介

不同的组织了解设计

设计上的沟通，是否能够满足需求

架构生成一系列的结果

设计的依据是什么？在文档中补充。

包括设计人员本身，了解为什么作出这样的设计结构

长期的系统的升级、对接等。让别人去了解。

新的设计人员的案例。

分布式开发下的支持。共同遵守的开发契约，如interface

##### 其他的activities

###### 设计上：

对设计的分析。通过形式化/半形式化，对架构进行建模。进一步的分析，要以架构文档为依据

###### 管理上：

系统被拆分为不同的element，之间有一定的依赖关系。通过拆解的结构，把系统开发工作进行划分。不同的部分能够分给不同的开发团队。不同的element可能存在依赖关系，由此决定了开发过程的先后关系，这种依赖关系一直持续到测试。根据结构的划分，进行项目任务的划分。

每次迭代加入更多的element，系统开发工作量变大。由架构设计决定了后期的开发管理。

###### 交付部署 维护阶段

以架构的文档作为维护的依据。系统寿命越长，架构文档的意义就越大。针对与外部的变化，如需求的变更，要把这些放在已经有的架构上，要依赖于文档。后期的变化在架构的框架之内。

如今的开发，是没有可预期的生命周期，更多的是在维护阶段开发。面对不断调整的架构。

#### Challenges In documenting architecture

##### 没有一个统一的标准。

不同的系统偏重不同的方面。

##### 很多的视图

大型的系统会有很多的视图，随着多次的迭代和系统规模的增加、ASRs。如何处理这么多的视图，生成被后续可以使用的文档

没有一个具体的，到底需要哪些视图。和具体的情况相关，没有统一标准。

##### 实时性和详细程度

先确定发布时间。开发工作有很大进度的压力；同时产品生命周期更从常，架构随着需求的变更而发生变化。因此，生成多么详细的、及时的文档的，是难以决定的。合适的规模、合适的更新频率。

##### 缺乏系统化的语言

没有一个通用的语言，只是在某个范围之内。没有广泛使用的架构标记语言，和对应的工具。

常用的UML。问题在于，描述不够精确，有的东西无法展示。

#### 文档的内容

ADD不同的视图，展现element和之间的关系。还有很多的东西需要文档进行定义。除了设计的输出，还应该有更多的东西。

##### 内容

###### 接口和依赖关系

###### Subsystems constraints

###### test scenarios

基于情景的描述方法，刺激响应，定义质量情景的六元素。它能够可以被转化、分解为一个或多个的测试情景。

###### 设计发生的周边环境描述

如何和外部环境交互，外部系统。并不是一个孤立的系统，指出和周围环境的关系。

##### 影响到架构文档包括的内容和描述粒度

###### 架构复杂度

越复杂，相互之间关系越复杂，越需要更加详细的文档。

###### 应用的寿命

生命周期越详细。面对的变化的数量和种类可能更多，所以就需要更加详细的架构信息。

架构要考虑今后遇到的变化。

###### stakeholders

比如，测试人员关注的信息是不同的。

对参与进来的stakeholder，和他们的目的相关。

### 7 Rules for Documentation

1. 从读者的角度取写

   不同的stakeholder

   以他们能够理解的表述形式、他们所需要的信息描述文档。

   如，考虑如何帮助维护人员进行维护，系统的异常处理机制的设计。

2. 避免重复

   每次迭代都有新的视图，并要说明当前设计焦点完成的需求，周围有和他相关的element。

   每一次输出都不可避免得有一些重叠，因此要尽量得去用最小得集合来cover整个设计的决定

   比如挑选一个视图的组合，让他们包含所有的设计决定

3. 避免模糊的描述

4. 使用标准化的组织形式

   文档的组织方式。

   设计中的输出是比较随意的，通过方块图连线、顺序图等等。

   整体的架构文档要用一致的形式。

5. 不但要有结果，还要生成结果的过程

6. current but not too current

   太频繁的更新会让效率低下。

   currency 和效率的权衡

7. review，查看是否满足了purpose

   是否满足了对于不同人员的要求。如对维护人员的支持。

### Views and Beyond

Views系列的视图，和视图之外需要说明的信息

#### Views

##### Styles and Views

11种架构分为三种风格，描述不同的信息

###### Allocation Style

和环境的对应关系

###### C&C Style

运行时，组建的动态关系

###### Module Style

结构的关系。强调静态结构

##### Style vs. patterns

###### pattern

不但要怎么解决问题，还要看解决的是什么问题、问题的场景

某一种形式，解决某种**特定上下文下的特定的问题**。

在问题和场景下解决问题

###### Style

关注架构的目的（architecture approach），一个抽象、轻量级的知道

不限定在什么样的环境。更抽象的一个指导

强调用什么形式组织架构。至于应对什么问题，不考虑。

###### example

微服务是pattern还是Style？

和SOA的区别是什么？

为什么要把SOA再进行拆解？

解耦，对企业的开发，整个的流程分开由不同的团队取进行。

微服务为了配合这种开发，他有具体的pattern，比如对于问题的隔离。

并不限定，而是一个普遍的结论，所以是一个style

#### Architectural Views

一系列的元素，相互之间的关系，拆分成不同的视图来展示。未必是全部，而是一个特定类型

不同的视角和维度去描述他。

不同的视图能够满足不同的用户和目标。

在特定的方面满足针对某些质量属性。

#### Structural Views 结构视图

文档的主要部分

结构视图

##### Module Views 模块视图

紧密的 对某些职责

任何一个系统

* Decomposition view
* Uses view
* Generalization view
* Layered view
* Aspects view
* Data model view

###### Module和Module的关系

从属关系

依赖关系

继承关系

##### C&C Views 组件连接件

runtime 行为属性

运行时状态，进程、对象、客户端、服务器、数据存储

附件只是连接件连接到哪个组件

* Pipe-and-filter view
* Client-server view
* Peer-to-Peer view
* SOA view
* Publish-subscribe view
* Shared-data view
* Multi-tier view

###### 元素

module变成的component

component和connector

提供服务，处理数据

数据的交换

依附的关系

###### 约束

只能通过connector连接

通过端口连接

没有孤立存在的connector

Usage

描述系统如何工作

runtime的行为、交互

外部的质量属性，要体现在部署之后，通过运行时的分析进行。

##### Allocation Views 分配视图

软件元素和外部环境的关系，如开发环境，需要的开发资源等

完成开发之后，执行环境，硬件、周边环境的要求等。如航空、汽车的使用环境

比较环境提供的属性和元素需要的属性来判断是否成功，两类元素是否匹配兼容

有静态和动态的视图。

* Deployment view
* Install view
* Work assignment view
* Other allocation views

###### 元素

软件元素和环境元素

关系

allocated

#### Quality View质量视图

某个特定的质量属性，屏蔽其他的element，只考虑相关的，来考虑影响

和结构视图可能有一些重复，不过表述的重点是不同的。

分析某一个质量属性是否被设计满足。局部测试。

* Security view
* Performance view
* Reliability view
* Communication view
* Exception view (error-handling view)

#### Documenting Views

视图的选择，并不是把所有视图都放进去

##### 3 Step 选择视图

1. view和stakeholder的关系。
2. combine
   1. 选择marginal视图
      1. 关心的stakeholder比较少。关注的多的价值更大
      2. 展示出的信息不完成、不详细
   2. 将marginal视图合并到别的视图里面
3. Prioritize and stage
   1. decomposition view 最重要，决定了之后的工作
   2. 80/20原则。20%的视图能够反映80%的决定。选择一个最小的coverage集合

##### Stakeholder and Documentation

明确每一个stakeholder的关注点

###### stakeholder-View Table

每一列是不同的视图，并进行分类。

对每一个的需要的详细程度不一样。

### Beyond

多个视图之间的关系、联系

文档的第一部分

文档的control 信息，什么时候改了什么之类的

视图的目录，谁会使用这个视图

架构的整体介绍，使用ADD方法，Views & Beyond, 哪一部分的什么视图

系统是做什么的，架构设计的需求

视图之间的对应关系

重要决定的依据和思考

设计中出现的术语的简单介绍





###### 作业

根据设计的输出，用V&B的输出进行记录和表示

















 