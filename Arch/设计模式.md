# 设计模式

#### 继承复用

fly()被所有具体的子类复用，但是紧耦合的关系，导致所有子类都被修改。

变化太频繁的时候，经常修改新增加的类或者原有的类

##### 改进

不是所有子类共享的方法，不应该被作为父类方法来继承

提取出来，作为interface，每一个子类依据自己的需求去实现接口，避免父类的修改去影响它。

##### 问题

行为被拿出去之后，被迫要在每个子类中实现行为。要重写的东西更多了。所有的子类全都要变，并且有重复代码。

根本原因在与需求的变化。

##### 分析

找到变化的根本原因。

###### 外在变化

客户提出的需求。

###### 内驱变化

如，使用的第三方软件的变换。他们是否需要封装。

技术栈的变化，比如换一个编程语言。

找到变化之后，将可变的封装隔离，避免影响其他部分。

##### 设计原则：封装变化

可变性封装，首先把变化的部分分离

把变化作为新的类，进行封装

封装的方式：接口/抽象类/…… 根据需求来决定

动态行为

这些需求意味着：

* 灵活的接口
* 动态替换行为

依赖倒置原则，可以替换不同的具体实现（行为）。

只要是一个可变化的部分，就可以被封装起来

通过行为类，代表一些行为，可以没有属性，构成一个类。

前面的设计还都是依赖具体

依赖导致原则，依赖接口来进行。

面向接口编程，就是使用的时候都使用抽象类型，引用的时候使用超类型。

保证接口的不变性。

##### 改进

Duck不再自己调用自己的方法，而是委托抽象类进行工作。

所谓的委托是对非本类的方法进行调用，委托别的类来进行处理。

通过合成的方式进行。

由抽象类型进行，完全不依赖具体，只依赖抽象，灵活性高。

##### 约束

behavior仍然需要设定具体的行为。

##### 动态变化

set函数变化

#### 策略模式

主要，封装可变、面向接口、合成复用，得到策略模式的设计模式。



硬编码：复杂的条件语句。

##### Consequences

模式的约束

###### 好处

* 更好的重用不同的算法/行为，通过继承关系更好找到算法之间共享的功能，更好的复用。抽象的中间理解共享的部分
* 成为一种替代继承的复用方式。通过委托合成，实现继承。
* 对于多条件的情况，更好的避免使用复杂条件，降低理解难度，增加可维护性
* 提供选择实现的方法，能够根据不同的情况去选择。

###### 限制条件

* 灵活性的代价是增加使用者的负担。要把不同的行为传给它。必须要对使用的方式、选择的完全了解。实际上是不利于使用的。
* 原来方法是本身对象的一部分，调用当前的方法。现在是委托调用，如果是一个简单算法，反复的调用将成为性能瓶颈
* 增加对象的数量。增加抽象必然增加对象的数量。增加的对象也不太好理解，除非知道模式，那就从模式来理解代码。辅助类并不具有“实际”的意义。

交流的时候，留在pattern level

##### How do we use design patterns

很多库也都是使用设计模式。

重要的设计模式

创建型

结构型 交互

行为型 对象行为的变化

### 简单工厂模式

创建一些来自相同输入的实例（由于依赖导致，他们都来自相同的父类）

为了管理这些子类，只要一个工厂方法来通过一些参数进行创建

将所有对象的创建放在一起

#### 模式动机

源自同一个基类，在创建子类的时候希望只知道子类的参数而不需要知道子类的名字。使用一个工厂的方法进行创建，只需要传递参数。

所有对象的管理在一起，有新的子类的时候，只需要对这个方法进行修改。

这个工厂不太需要创建工厂对象，方法只需要作为一个类方法（static）。

#### 模式定义

也叫静态工厂方法，类创建型模式（由类/继承的方式实现,不需要实例）

根据参数的不同返回对应的实例。

被创建的实例一般具有相同的父类。

返回的是**抽象类型，**创建的是具体类型。提高代码的灵活性，用一个方法创建不同的类。

#### 模式结构

Factory

Product

#### 分析

实际上整个代码没什么变化，就是把创建的部分放在一起。

复杂性转移，降低每个模块的复杂性，工厂本身是复杂的。

策略模式的缺点在与创建不同的策略，由客户决定使用哪个策略。如何创建和管理就是一个问题。由工厂模式管理策略的生成。

工厂模式非常适合和其他模式共用，因为任何模式都需要增加对象，对象的创建管理可以通过工厂模式。例：装饰模式。

##### 优点

* 创建和业务处理分离，降低系统偶合度，实现了责任的分割，隐藏创建细节，让两者的修改都更加容易。
  * 单一职责。
  * 对每个对象来说，都有对象的创建和使用。更好得把对象得创建封装起来。防止使用得时候和类的具体类型产生耦合
* 由于是静态方法，使用起来非常方便
* 实际上可以将参数保存在XML中，修改时无需改代码（所有工厂都可以引入配置文件）

##### 问题

工厂类的职责太重

工厂里面还是拥有大量if-else，违反**开闭原则**，系统的拓展困难，增加新产品的时候要修改工厂逻辑。

静态方法没法提供灵活性。工厂角色无法形成基于继承的等级结构。

集中了所有产品的创建，一旦不能工作，整个系统都受到影响。（所有的集中的模式都有这个问题）

具体耦合，由类产生具体对象

##### 要点

需要什么就传参，不需要知道具体类型。

#### 例子

实际上还是有“代理模式”。

#### 适用环境

工厂负责创建的对象较少、修改的可能较少。（主要关注变化比较少）

客户端只知道参数，不关心创建的过程

#### 实际例子

##### 日期

```java
java.text.DateFormat
public final static DateFormat getDateInstance();
```

给一个参数，返回具体的类。实际山故事不同的策略。

为了得到不同的策略，在创建的时候使用简单工厂

##### 加密

不同加密算法的密钥生成器

#### 模式拓展

##### 简单工厂模式的简化

通过抽象产品角色本身扮演工厂。直接把静态工厂方法写在抽象产品类中。

### 工厂方法模式

注意，这不是抽象工厂。

#### 模式动机

工厂模式本身违反**开闭原则**，增加新的具体对象类型时必须修改工厂代码。

定义抽象工厂类。

由客户代码依赖抽象工厂，修改得时候增加具体工厂，相比简单工厂，完全符合开闭原则。

客户不在依赖具体工厂，而导致增加得时候具体工厂得改动。

具体工厂的创建

#### 模式定义

也叫工厂模式，虚拟构造器模式或多态工厂。

使用继承和多态实现开闭原则。抽象工厂是使用合成实现，每个具体工厂是职责复杂的。工厂方法还是主要关注创建具体的对象。

类创建型模式。

由工厂父类决定创建的接口，具体的创建放在工厂子类中进行。

“具体延迟”，使用抽象的工厂父类的目的是把实例化延迟到工厂子类中。到必须使用具体化得的时候在才指出具体类型。抽象工厂中不再决定哪个具体对象被创建。不是时间上的延迟，而是设计上的。放到多态中的具体子类。

每一个具体工厂负责一个具体的产品。

一个工厂方法也可以创建多种产品。每一个工厂生产一组类似的产品，接受参数给出不同的产品。只是把容易变化的进行分离。

#### 模式分析

核心的工厂类不再负责所有的产品创建，每个不同类型的产品由不同的具体工厂进行创建。中心化、不符合开闭原则的缺点被克服。

从静态方法变成抽象方法，工厂变成抽象类

实际上是创建不同对象作为一种策略。要创建的时候用具体工厂来进行。

模板方法模式会退化为工厂方法。

要得到具体产品的时候，还是需要创建具体工厂

#### 模式实例与解析

日志记录器

#### 优缺点

##### 优点

不需要知道实例化细节，不需要具体产品的名字，只需要知道具体工厂。创建得过程完全被封装在工厂中。工厂的多态。

增加具体工厂，系统可扩展性更好。

很多对象相互依赖，这种复杂的创建规则（比如先后关系），通过工厂进行封装。

##### 缺点

引入抽象层，可理解性下降。

放在不同的类之间，没有创建间的依赖关系？

##### 适用环境

* 不知道需要的具体对象的类，隐藏产品对象的创建过程。
* 通过子类指定创建对象，增加灵活性
  * 更有灵活性，通过具体子类创建
* 配置文件，动态绑定

每个具体工厂对应一种具体产品，工厂方法具有唯一性，需要生产具有一组有依赖的关系的时候，（多个相互依赖的产品），而不是单一的产品的时候，就出现问题。这时候管理是困难的。无法实现这种创建的依赖，额外的方法会造成具体的依赖，造成具体耦合。

### 抽象工厂模式

总之是产生互相依赖的多个产品

每个具体工厂当中至少有两个工厂方法。工厂方法对应一个产品等级结构。

产品等级结构：产品的继承结构。继承结构就是等级结构，具体的子类是低等级。🌲所有产品都是一个类型的

产品族：一组产品，每一个产品位于不同的产品等级结构。这些产品相互依赖，完成一些任务。

原来工厂负责等级结构的一个产品，抽象工厂负责生产一个产品族

当需要的不是单个产品，而是具有相互依赖的不同产品等级结构的一些产品，需要抽象工厂。

最抽象和一般的工厂模式形态。

抽象工厂面对多个产品等级结构，当工厂等级结构可以创建出分属于不同产品等级

抽象工厂描述了这些产品之间的耦合。

一系列相关或相互依赖的对象的接口，无需制定他们的具体类。

别名Kit模式。

抽象工厂不是工厂方法有抽象层，而是比工厂方法更为一般。

例子：Button Text，两者的组合需要用客户代码，有两个工厂然后由客户固定依赖关系。使用抽象工厂的时候，依赖关系在工厂当中。

分清楚需要创建的对象和创建对象的对象。

#### 实例

对象是合成的、方法调用、一个对象做另一个参数，耦合信息都没有说明，这些信息还是与其他模式进行组合。抽象工厂

生产同一组属性的对象，找到产品族，形成抽象工厂。之后怎么使用，耦合关系，和抽象工厂都没有关系。

#### 优点

作为工厂模式，隔离具体类的生成，减少用户类的职责，不需要直到什么东西被创建、怎么创建。更换新产品比较容易。具体工厂实现相同的工厂接口，改变系统行为就可以通过改变具体工厂的实例。

所有的耦合全部被内聚在工厂之间，具体产品的耦合内聚在具体工厂之间。这样可以使得客户端高内聚低耦合。

多个对象被一起使用的时候，能够保证只使用一个产品族的对象（耦合被工厂封装）。

新的具体工厂和产品族的添加很方便，符合开闭原则。新的具体工厂就是新的依赖关系。但是新的产品等级结构呢？不可以

#### 缺点

难以扩展年新的产品等级结构，没法扩展新种类的产品。由于规定了所有可能被创建的产品集合的接口，如果添加就要修改的所有接口

开闭原则的倾斜性

具体工厂角色定义具体产品的耦合，在工厂方法中没有这种具体耦合关系。这种具体耦合依赖关系，具体工厂是面向具体变成，新添加的产品的耦合，就要被迫修改这些面向具体编程的耦合。

实际上是，开闭原则倾斜于客户端，让耦合被封装在工厂当中，导致工厂的开闭原则下降，牺牲模式当中的开闭性。

大部分设计模式少有这种倾斜性。

#### 适用情况

系统不应该依赖产品类实例如何被创建、组合、表达的细节。（如果需要管理创建的过程，就去适用工厂方法模式）

需要同一个产品族的功能的时候

属于同一个产品族的产品将在一起使用。系统就是有多个产品族，只需要用到某一个产品族。类似配置，性能最佳配置、最佳安全配置……对象行为变化，一组策略同时更换，这些策略之间没什么依赖关系

一个产品族，或者有依赖的对象。

#### 工厂的退化

### 建造者模式

#### 模式动机

对象需要协同、耦合、内部类等方式一起工作，把他们耦合在一起，不由抽象工厂管，而这些细节不应该被构造函数全部负责，因此再进行封装抽象。

复杂的对象，有多个组成部分。比如引用，指针，内部对象等。复杂对象（复合对象），用户不需要知道装配细节，只想直接使用。组件的创建和组件的组装分开，使得其能够复用。

简化创建和组合的过程。

尤其是有些时候有闲置条件，比如赋值的顺序、引用给哪个对象，等等

有外部的建造者负责创建和组合，返还产品建造完成的产品，用户不需要知道组装方式。

#### 模式定义

构建和表示分离，让同样的构建过程可以创建不同的表示。

一步一步创建一个复杂的对象。

#### 模式结构

抽象建造者

具体建造者

指挥者

产品

build里面可以是自己创建，也可以通过抽象工厂的方法。一个创建，一个构建。

通过改变具体建造者，能够修改过程

为了不把具体创建过程暴露给用户，就把创建顺序、流程，用指挥者对象封装。

#### 优点

屏蔽对象组装的细节，内容和创建过程解耦。

通过替换建造者，得到不同的产品对象。

更精细得控制产品得创建过程

#### 缺点

产品内部变化负责，就需要很多具体建造者类，系统变得很庞大。

产品差异性大就不适合适用建造者模式，而需要使用工厂

#### 建造者和抽象工厂的比较

两者正好互补。

### 原型模式

#### 模式动机

对象自我复制

通过复制原型对象，避免频繁创建复杂对象，修改一些东西就可以创建很多其他对象。

#### 模式定义

原型模式支持创建可定制对象而不知道任何创建过程。

抽象原型类，支持克隆方法，传回原型对象

#### 模式分析

深克隆

保证不是一个对象，是同一个类型，equals()

#### 应用

邮件复制

#### 优点

提高对象的创建过程，简化创建结构

深克隆能保存对象的状态。

#### 缺点

为每个类实现克隆方法，对已有的类不一定是容易的，需要修改代码，违反开闭代码。

实现深克隆要有更复杂代码

#### 适用场景

新对象创建成本的大

每个对象有自己的内存空间，互相不同。

变化很大，内存很大，用状态模式。

避免适用分层次工厂创建分层次对象

原型管理器就是哈系表，全部创建好，需要什么就直接用Key返回。

## 行为型模式

### 状态模式

#### 模式动机

对象的行为取决于一个或多个动态变化的数型（状态）

对象与外部事件产生互动的时候，内部状态产生变化

状态变化引起行为变化。相同的方法具有不同的表示行为

使用if-else，不符合开闭原则，增加状态或者行为要修改大量代码

在这个情况下，变化的是状态和对应的行为

策略模式中，将行为分离，在状态模式中，将状态和相关行为分离，通过改变状态对象，使对象对外表现出随状态变化，用户不必关注状态。

#### 模式定义

准许对象在内部状态改变的时候发生行为变更，对外看似是修改了类。

封装变化的状态，改变行为。

对象行为型模式

#### 模式结构

三类角色：环境类、抽象状态、具体状态

不同的分支对应部分抽离封装为不同的状态。每一个行为中，有关该行为的状态抽离，形成具体的状态。

保留抽象状态的引用，根据不同的具体状态有不同的具体行为

##### 相比较于策略模式

结构图完全一致，形成的方法也是一致的。

实现和使用方式的都是不同的

#### 模式分析

委托不同状态类执行，引入抽象状态类，不同具体状态类有不同的行为，包括**状态的转换**，策略模式中，不需要模式来转换策略，但是状态模式要在模式内转换状态。

不使用状态模式时：行为中判断状态，或者状态中判断行为

使用状态模式，所有的方法全部是接口，具体实现委托抽象状态类，根据具体现在是哪个状态进行不同行为。通常使用抽象类而不是接口，因为具体状态类大多是只实现其中一部分接口，需要默认行为。

封装转换规则到具体状态类，（只有具体状态类直到当前状态，环境类似乎并不知道当前状态），传入context的引用。

实际上，新创建状态对象会产生太多，每次new浪费资源。环境对象变成状态对象的管理器，每次setState不应该new，而是从环境类中取需要的状态类。

状态对象没有属性，因此可以声明称为静态成员对象进行共享。

状态类和环境类的关系：

1. 环境类中对状态进行管理，可以在其中进行切换（修改更方便）

2. 抽象状态类一般是抽象类。

状态经常切换、不同状态下对象的行为不同

context是客户实际使用，客户无法看到状态的转换，不需要考虑这个问题。

状态模式能否完全支持开闭原则？否。新增状态，新状态的source状态需要被修改，取决于新增加状态的源状态的数量。

在策略模式中，由于各个策略之间没有耦合关系，因此是完全对开闭原则支持。

就算setState放在context，又无法满足状态模式的根本原则。

这时候希望把所有的状态转换放在一起。

根据属性值，改变状态改变的方式，所有状态转换仍在具体状态类中。

也可以，通过，将规则根据属性变化进行跳转，此时属性可以放在状态，或者context。状态切换用context进行，适应状态的新增，也可以放在context中，通过context进行状态切换

原则：行为引发状态变化，在具体状态类型；根据数据变化；状态变化简单的时候，也可以通过context执行。状态类实现行为决定的动态规则（不好维护）

和代理模式联用，子类调用父类的方法，不提供其它接口，通过父类state调用，实现类进行实现，派生出来的状态不需要具体实现，再委托背后的类进行。

### 命令模式

#### 模式动机

向某些对象发出请求，但不知道接受者是谁，也不知道被请求的操作是哪个。

指定一个处理程序。

消除请求发出和接受者消除耦合。灵活性

#### 🌰

线程不需要具体的调用

不想知道具体的调用方法，能够复用。

发送者需要统一接口封装不同接口。不同的方法调用成为同一个方法调用。

#### 模式定义

请求封装为对象（统一接口）。可以使用这个对象，参数化客户（开关/线程，接受不同的任务）。行为转换为数据

request是行为，参数化针对数据。

耦合的方法调用，变成跨进程空间和时间的对象。方法调用是同步的行为。

#### 模式结构

抽象命令类 具体命令类

调用者 接受者 客户类

client是模式内部角色，负责创建命令对象。

Invoker 真正执行命令，数据对象命令，等待别人来使用，Invoker调用execute。什么时候去调用不在client决定，由Invoker负责。Invoker可以是一个线程，什么时候执行都是根据Invoker决定，调用command。数据对象给不同的Invoker，实现空间和时间的变化。这取决于哪个Invoker何时调用。

在这之前：回调。实际上是非面向对象的命令模式实现

#### 模式扩展

宏命令/组合命令

命令模式和组合模式联用

