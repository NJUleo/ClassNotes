# Advanced JavaScript and DOM

### Events

事件处理器通过回调的方式处理事件

#### 观察者模式

主题发生状态/属性变化，通知观察者进行响应的操作。

##### 特征

主题和观察者之间解耦

广播通信

##### 需要注意的

可能造成内存泄漏。解除绑定时出现错误，可能造成主题中仍有观察者造成内存泄漏。

#### 原型库绑定

#### DOM 2 Event Types

UI 鼠标 页面状态（页面加载完…） 键盘相关

异步方式对变化进行响应。

#### H5 新事件

### Event handling models

#### DOM Level 0

一一对应的模式，直接简单

#### DOM Level 2

##### Event flow

事件从根元素向上传播到根节点。

捕获：从根节点到目标节点的父节点

目标节点阶段

冒泡阶段：事件从目标节点到父元素，再到根结点，冒泡

控制在哪个阶段进行处理

DOM 0 就是目标节点的阶段（类似）

职责链，事件的处理有一系列对象相关联。事件在链的结构进行传播，每个对象，如果有事件处理器就对对应事件进行处理，知道尾端。一种解耦合的方式。缺点在于，可能传播一遍没人处理。最后加上默认的处理

最后一个参数，true对应捕获阶段，false对应冒泡阶段

### Scope and Closure

#### 变量声明周期

从声明开始

函数内的，在函数创建时创建，结束是失效

全局变量，和当前页面相关

#### 闭包

类似于私有变量

匿名函数的方式

嵌套子函数能访问父函数变量，作用于外延

内部函数比外部函数具有更长生命周期

this动态类型。this永远指向全局的

保护命名空间。

有可能造成内存泄漏，长期驻留内存

#### Scope Chain

标识符解析，从Scope chain依次寻找，解析。作用域靠前的先找到。

调用全局变量，会遍历作用域链，效率比较低

with，改变作用域，插入作用域链的最前端。问题在与访问别的局部变量更慢了，整体性能下降。

由于闭包存在，活动对象销毁时，闭包仍持有其引用

### JS实践建议

三者关注点分离

#### 避免全局变量

全局变量增加不确定性

局部变量需要显式声明，否则成为局部变量

严格模式，不准许无声明的变量

#### 严格模式

ES6 自动采用严格模式

行为、性能、安全性

语法解析和运行

#### 变量声明

避免重复声明，统一声明

声明的时候初始化

#### 不声明数字、String、Boolean对象

建议按照原始值的方式使用，不当作对象

当作对象，性能降低

高效安全，跟对象的关联由JS引擎管理

#### Don't Use new Object()

不使用new

字节数减少

不容易出错，更安全一些

#### 注意自动类型转换

JS弱类型，根据当前上下文自动转换，需要特别注意

#### 用===更安全

值和类型同时比较

#### 参数缺省值

避免出错

#### 避免eval

文档当作代码执行，性能问题、安全性问题

#### 原生JS一定效率跟高

效率

对未来兼容

不可避免的使用第三方类库，提升开发效率

#### 函数表达式

匿名函数，赋值给变量

函数提升

#### 方法自变量

按模块划分，容易组织。

方便重构

#### Hoist

后出现的变量声明，改变其Scope，但是还没有赋值

#### Prototypes

原型对象被所有对象共享

#### Class

#### 模块化

引入值

ES6 引入引用

循环加载，第二次引入从上次的位置开始

ES6 第二次引用不再跳回去，当前的执行完了再回去，没有循环

#### 正则表达式

当前文本的规则

## 作业 2

服务端 Node.js（主要登陆注册）

以第一个作业为前端页面

服务端实现2类功能，登陆注册、图片视频的加载

需要注意，用一点数据库，用户信息保存于数据库，图片视频保存于文件系统

注意 

* 用户输入的验证 
  * 浏览器、服务器混合验证，文本模式在浏览器，验证在服务器
* 输入信息的文本模式
  * 以前偏向策略模式 
    * APPLE网站，注册的时候有复杂规则，
    * 把验证分成多个规则，每个规则验证一个部分做成一个函数，依次验证，没通过的进行提示。验证规则的集合
    * 登陆的时候用户名或者密码有一个错误，不能太明确，到底是哪个错了，安全性。除此之外给出更加详细的信息
  * H5和策略相结合
* 密码怎么存？
  * 加密存放，不能以明文存放数据库
  * 哈希
    * 哈希映射字符串是不可逆的
    * 也可以攻击，单纯用哈希也不好
    * 加盐——数据库保存随机生成的随机数
    * 哈希计算必须在服务器
    * 盐不能被传出服务器
  * 不对称加密
    * 保存私钥的管理，设计安全和复杂性
    * 每个用户都需要单独的私钥
  * 计算机的随机数是伪随机的
* 验证码
  * 