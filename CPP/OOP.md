# OOP

### 为什么OO

##### 非OO

无法保证操作和相关数据耦合

非OO的数据访问没有权限说明

对数据的直接访问破坏封装性

无法对数据和行为进行管理和控制

##### OO solution

封装成为类

class本身没有任何创新的地方，本身的差异仅仅在与支持对原来数据加入行为。

struct也支持封装方法，它和class的区别只有访问权限，除此之外没有任何区别。

访问权限是在Cfront中，是静态的，只有在编译前能去进行限制。

Cfront加了一个隐藏的指针this，本质上和面向过程还是一样的。

#### 什么是OOP

过程：控制流的变化

OOP中变成了在数据域中相互跳转，用消息传递

本质上，就是向对象发送消息。

#### 评价标准

在规定条件下和规定时间内完成规定功能的能力

面向对象更符合人解决问题的思路。

人的思考往往是从职责来划分事情，而不是步骤。职责容易在问题域中得到，很容易映射。

更多的类型检查，更好的支持

因为类型有更好的组织，不需要指针，使用更好的引用来进行。正确性提高

### 封装

#### 成员变量和成员函数

一般分开，声明文件只给出接口和数据生命，定义在另一个文件中给出

定义的时候使用域操作符指明。

（并不是强制的）

可以直接定义在头文件里，声明定义同时完成。

差别在与，分开时候，函数定义为普通的函数

后者，建议编辑器处理成内联函数，有更高的效率。直接把方法体替换，不存在调用过程

相比于宏，宏没有类型检查。

内敛函数是更安全的优化。

但是，CPP追求效率，复制代码减少函数调用，但是代码过大会导致程序过大，占用太多的空间。通常，存在循环的、函数很大、多次调用，造成程序过大，编译器会拒绝内联化。就算是加上inline，编译器也可以拒绝。

##### 什么函数应该放在头文件内联化？

get set

这种访问非常频繁，函数本身简单，适合使用内联。

很多聪明的编译器的优化就会自动把一些函数内联化编译。

#### 对象的创建

```c++
Tdate g;//全局静态区
int main(){
	g.SetDate(2000, 1, 1);
	
	Tdate t;//栈区
	t.SetDate(2000, 1, 2);
    
	Tdate *p = new Tdate;//堆区
	p->SetDate(2000, 1, 3);
}
```

对象创建之后必须进行初始化。

#### 构造函数

对象的初始化，强制的

编译器自动调用构造函数，进行对象初始化。

没有返回类型（不是返回void）

构造函数可重载。

默认构造函数 当类中没有构造函数的时候，编译系统提供

* 用默认值进行初始化。比如指针和数组赋值为0，函数变量不初始化
* 没有参数
* 有的时候还是要写默认构造函数，在提供了带参数的构造函数之后就编译器没有默认构造函数了。C++的理念：用户应该表示清楚其理解。
  * 通过带参的构造函数屏蔽默认构造函数，可能是用户的意图。
  * 很多情况下，默认构造函数是默认被调的

也有访问说明。可以定义为private，接管对象的创建（单键模式）

#### 成员初始化表

在一些场合下，构造函数还不够

```c++
class A{
    private:
		int x;
		const int y;
		int& z;
	public:
		A(): y(1), z(x), x(0) {x = 100;}
}
```

表优先于函数体

表内的顺序根据成员生命的顺序

初始化表的参数来自构造函数的调用

```c++
class CString{
	private:
		char *p;
		int size;
	public:
		CString(int x):size(x), p(new char[size]){}
}
```

##### 为什么要用成员初始化表？

###### const和引用

常量的声明和引用必须在同一时刻，所以需要把常量创建的时候直接初始化。

开辟空间的时候直接赋值，减轻compiler负担

开辟空间，之后再进入函数体。

引用和常量必须使用成员初始化表。

###### 对象成员

C++当中，是直接嵌套而不是引用。嵌套的类，是要同时初始化成员变量中的类。

在b的构造函数的时候，A已经进行了初始化。

通过初始化表可以直接对A初始化。先对对象成员进行初始化（此时可以使用非默认构造函数），然后在进行子类的其他初始化操作

##### 分析

效率更高

数据成员多的时候，可维护性差，不需要满足这一准则。

#### 析构函数

~<类名>()

对象消亡的时候（声明周期结束）系统自动调用析构函数。

释放资源

java中自动进行 GC，效率比较差。

对于效率要求高的情况下，C++的方案更合适。

析构函数可以作为private 可能消亡的时候，是编译失败的（局部变量）。只有new可以，它的消亡是需要显式得delete。

**强制自主控制对象存储分配**，只能放到堆里面，适合非常大、不常用的类，如果放在栈会占用太多空间。

类当中的指针，类自身new出来的空间，必须需要自己释放。

#### 拷贝构造函数

准许在创建对象的时候用同一类对象对其进行初始化。

自动调用

C++内的对象的函数参数传递或返回值传递是值传递

因此需要显式得说明拷贝过程方式出现问题。

必须加上引用，否则又是值传递，无限循环。

（如果传参数，都要用常量引用得方式。）

默认得拷贝构造函数，逐个对成员初始化，按位拷贝。

在有一些场合中，必须显式得去写出来。一些动态获得得资源

* 默认拷贝构造函数，按位拷贝，则指针成员变量会指向同一个位值。在这种情况下，其中一个对象调用析构函数得时候都会把另一个对象得空间给delete掉。“悬挂指针”。
* 很多情况下，这种情况很可能造成，悬垂指针在特定得情况下出现bug，对bug得定位非常不利

解决：深拷贝。对于指针得成员变量，拷贝得时候要申请新的空间。

##### 嵌套的情况下

默认拷贝构造函数，调用成员对象的拷贝构造函数

自定义的拷贝构造函数，调用成员对象的默认**构造**函数（编译器认为，你没有说明使用A的拷贝构造函数）

拷贝构造函数前面写上，调用拷贝构造函数

#### 转移构造函数

对确定是常量或者不会改变的，能够直接不用拷贝构造，而是直接改变指向的地址？

右值引用。

数据 类型的左值右值

为了区分拷贝和转移构造函数，就看参数的匹配，看能否赋值给对应的构造函数。

右值只能给右值引用，左值一样

std::move()强制把左值转成右值，调用转移构造函数。

但是需要保证，之后不能再改变这个引用的值。

如果改动其中一个，必须要明确提出其他的或者要求编译器提出。

### 动态内存

需要创建动态的对象的时候，动态生成。

栈 堆都是操作系统进行实际分配

C中 malloc() free()

这种方式，能否实现动态的对象分配？

对象实际上要调用构造函数，使用malloc()，构造函数没法去做。

C++中 new delete

new会去把构造函数进行调用

#### 动态对象

再堆中创建。

不使用malloc的原因是new/delete能够自动调用构造函数和析构函数。

new也可以创建基本数据类型。

创建的是匿名对象，**必须**通过指针访问

new作为操作符，可重载

#### 对象删除

delete之后，最好把它置NULL，避免错误的访问

减少二次释放问题

###### delete void类型的指针

delete要归还空间，必须要知道大小，调用析构函数，需要看指针

只delete只会free空间，不会调用析构函数。

#### 动态对象数组

不能显式初始化，必须要有默认构造函数。

delete的时候不能省略[]，否则就是只删掉了第一个。

因为实际上P就是一个那个对象的指针（指向第一个），并不知道是一个数组。

#### Const 成员

常量再对象声明周期中不变

在构造函数的成员初始化表进行

##### const 对象

对象成员变量也可以作为常量。

对象不可更改，数据不可更改

方法定义在不同的文件中，编译器不知道该函数是否修改数据。

要求程序员告诉编译器是否是const的方法。

在方法的后面加上const表示是常成员函数，让编译器知道该函数不会改变。

在定义的文件中，同样也要声明常成员函数，由编译器进行检查。

const实际上是把this变成const

常量对象只能调用常成员函数

建议，所有能被声明成常成员函数的，就声明。

const可以重载。常量对象调用常成员函数，非常对象调用非常成员函数。

常量对象，是自己占据的内存不能改，并不代表它指向的对象不能改。

编译器没有办法限制对常量对象的访问。转成非const就行了。

mutable，分开，可以在常成员函数修改。

#### 静态成员

同一个类的不同对象共享变量。

静态成员变量，共享的相同属性。

定义为全局变量的话，缺乏数据保护，没有访问限制；名污染

static

所有类对象共享，唯一拷贝，遵循类的访问控制

需要在类的外部定义

只定义一次，不能放在头文件，头文件中可能出现重复定义。因此通常放在实现文件中。

必须出现在类外，必须只定义一次。

如果恰好是个const类型，和全局常量是没什么区别的，准许类内定义，但必须是常量表达式，通过编译优化变成全局常量。

##### 静态成员函数

直接通过类来访问静态成员变量。

不需要用对象，而直接使用静态成员函数、静态成员变量。

遵循类的访问控制。

```C++
A::f();
```

看上去就是一个全局函数和命名空间。

C++认为，类也是对象，提供一致的访问方式。

##### 静态成员的应用

对对象进行计数

单键模式，可以通过静态成员来实现。不需要创建对象就可以调用，所以可以控制对象的创建。

protected构造函数

用静态方法创建

原则：谁创建谁归还

### 友元

访问权限降低了private的访问效率，缺乏灵活性。频繁访问私有成员的时候，会有性能代价。

C++追求的第一位还是效率，还是提供高效的使用方法。

数据访问控制+私有成员访问效率

声明成为友元的时候可以去访问私有成员。部分开放私有成员。安全性由程序员保障。

没有传递性

#### 实例：矩阵向量乘法

用户（乘法方法）能够保证安全性。避免大量的频繁通过方法访问私有成员变量。

#### 分类

* 友元函数
* 友元类
* 友元类成员函数
  * 必须有那个类的完整声明

友元声明未必需要那个函数的声明。（除了友元类成员函数，那个成员函数必须声明，否则编译器认为数据不一致）

友元没有传递性；跟继承也没关系

```C++
class Zhang{
    friend class SG;
    friend void CZX::watchShuaiGe();
}
```

##### 笔试

概念解释（上半学期多一些，理念性的）

看代码写结果：能否编译，执行结果、错误原因

代码设计题，跟作业差不多

#### 不完全声明

先声明后使用，在Matrix里面，还没有声明Vector。因此不能编译通过.

所有的东西都要先分配空间，函数的压栈。所有的引用指针不需要多大，只需要确保这个类型存在。一个不完全的声明，不需要里面的所有内容，只是说明之后回声明。解决“死锁问题”

除了友元，函数也可能有这个问题。都通过不完全声明，来避免这个类型需要相互声明。

#### 原则

避免将数据成员放在公开接口。最烂的是把所有成员都提供get set。

要分清，所有数据的可读可写性。

### 单继承

继承的父类的访问权限。

本质上基类是子类的一部分

#### 成员变量的权限

private的，子类不能访问，protected是所有派生子类可以访问，外部无法访问

子类类似于合成了父类，一个特殊的“引用”来进行访问。

#### 方法的权限

函数重定义，子类函数与父类函数一样的情况。

不是动态的，而是静态的。

如果是多态，必须父类用virtual声明

实际上只是命名空间的不同。在子类的命名空间。父类的函数也没了，同名函数被屏蔽。

不能简单的进行函数重载。

#### 访问权限的变化

向严格方向变化。可以在派生类将公有的声明为私有的

最好加上using。如果没有using和基类，又变成了重定义。

访问权的改变，实际上是改变它自己的派生类的权限。

注意，C++的函数调用，一个是名字寻找，只有同名下才有重载。只要找到名，直接进行类型检查，不会说，名字找到而参数不匹配就去别的名空间。自己的名空间找不到就去基类名空间找。基类有大量重名函数，只要在子类有一个同名的重定义，那那些全部都不能被调用了。

命名空间的隐藏。尽量不重写非虚函数

只有派生类找不到才会去基类找

构造函数、析构函数不能继承

#### 继承方式

public 

private 继承：派生类不能使用

protected

一般都写public，否则默认私有继承，再被派生的时候是私有继承

一般认为私有继承是没什么意义的。

#### 不完全声明

不能写继承关系。只有完全声明才能继承。

#### 友元和protected

友元的传递性问题。

派生类继承基类，派生类有访问protected的成员变量。

那么子类的友元，是否能够访问protected？不可以

不能访问基类的变量。否则只要声明一个只具有友元的子类，直接破坏protected保护。

只能通过派生类来访问私有变量。

是谁的友元就只能访问谁的变量。

### 继承

对象创建的过程，比较神秘

派生对象的构造，由基类和派生类共同完成，各自完成各自的部分。

层层递归调用

##### 顺序

基类构造函数

按声明顺序，成员类的构造函数

派生类的构造山树

（析构函数顺序正好相反）

#### 构造函数的调用

如果需要基类的非默认构造函数，用成员初始化表中指出

只能调用直接基类的构造函数。

#### 拷贝构造函数

跟构造函数一样。

没有指明，则调用默认构造函数

需要拷贝，必须要指明，调用编译器的拷贝构造函数。

```C++
B(const B&b):A(b)
```

其实拷贝的是B中的A，直接把B给它

???

using A:A//继承A的构造函数（所有的构造函数）

这样所有的基类构造函数全部被继承。此时编译器为所有的构造函数，生成B的对应构造函数，可以直接调用B的。

using可以把父类所有同名函数继承，在这之后进行重载，就不会把其他的同名方法覆盖。

using不能改变构造函数的访问权限，普通成员的是可以的。

这些好处在与，全部通过编译器决定。

### 虚函数

运行时刻决定。

#### 类型相容 赋值相容

a = b是一个赋值函数，拷贝操作，从b中，按位拷贝到a

```C++
A a;
B b;//class B : public A
a = b;
```



对象的身份发生变化，结果是编程A类型的对象，派生类的属性完全失去。对象切片

赋值相容，对象休息被丢弃。

```C++
B* bp;

```

只是地址的情况下，对象身份没有变化

类型相容，比赋值相容更完整。

向上引用是可以的。

#### 虚函数

只要被创建为虚函数，所有派生类的也全都是虚函数。

#### 限制

类得的成员函数

静态成员函数不可以，类独有的

内联函数不行，编译确定

构造函数不行，因为虚函数调用子类函数，但是构造的时候不能这样做。另外，要实现虚函数，派生类要有虚函数表，记载实际的函数地址，在构造函数期间构造，在这之前没有这张表。

析构函数往往是虚函数。事实上，建议所有析构函数都是虚函数。这样能够保证完成删除，防止派生类额外的资源没有被释放。

#### 后期绑定

为每一个不同类型的对象生成对象关联的函数表

函数表和对象本身的内存关联，从对象内存找对应的函数表

为每种类型生成虚函数表，在对象中增加一个只向对应虚函数表的指针。

调用的效率上低一些，要首先查找调用的函数表和对应的函数地址。

函数调用

传的P实际上是this指针

```C++
(**((char *)p - 4))(p)
p->f()
```

实现就是查表

虚函数表的构建是**创建**的时候（构造函数调用时）。构造函数中的虚函数是基类的。

实际上是A对象先创建，再创建B对象。首先再父类的构造函数的时候，是构建父类的虚函数表

只有子类的构造完成之后，才具有多态。

构造对象的过程中，只要在构造函数执行期间，其状态（类型）是变化的（虚函数表未完成

）

静态绑定，只根据指针类型调用。

构造过程当中不太一样

总的来说，虚函数永远通过表来找，非虚函数永远找this，当前类

虚函数调用非虚函数

非虚函数调用虚函数，复用一部分父类的非虚函数，同时能使用子类的虚函数，实现模板模式

#### final & override

C++既可以重载又能重定义

名字写错了可能出现难以察觉的bug

引入override关键字，重载的时候声明override

虚函数重载必须要求参数和返回类型都一样，比较安全

final关键字表示方法不可重定义

#### 纯虚函数

加上“ = 0”，表示“not there”，实现不在这个地方。

**往往**只给出函数声明不给出实现

类似抽象方法，但其实也是可以给出实现。不能用内联的方式直接给出，但是能够在实现文件中实现

抽象类：包含了纯虚函数的对象

不能用于创建对象。

派生类不显式调用，还是没有实现，不能被子类继承。需要重新给出实现。除非是给出基类的名字来直接调用它的实现。（子类方法里，写出来Base.f()）实际上是有可能比较多出现的实现

纯虚函数不能实例化，不会出现，因为没传指针而造成对象切片（直接传参不被准许）用作接口。

_pure_virtual_called 不完整的表，只会通过派生类的提供这个表项的具体地址

#### 虚析构函数

不是虚函数就不能正确识别类型而不能释放派生的成员

由于子类都有析构函数的定义，所以转移构造函数都要由

构造和拷贝不需要自己管，但析构函数要自己定义，否则它只管派生类的资源

析构根据绑定指针类型进行，如果不是虚函数，就无法正确得析构派生类。

#### 继承的不同方式

##### 公有继承

合成和继承的不同关系，不要使用继承复用，多用合成，因为继承的时候是认为基类和派生类是同一种，要提供统一接口

继承之后，要提供额外的、不需要的接口。

继承的关系，就是认为“是”

调用虚函数就是动态运行是决定（查虚函数表），访问控制是在编译是确定

只要是基类声明公开接口，在子类中就必定公开，失去的访问控制。通过基类接口调用了子类的私有函数

问题就在于，不符合Liskov代换，一定是前置条件更弱才行，不能有更多的要求。换成子类，破坏了子类额外的规定的时候就出现问题。

正方形是长方形的特例，约束条件更多，恰恰让它不能作为派生类。

父类的实现不能让子类用，通过非虚函数作为公开接口，调用私有虚函数。子类不能通过非虚函数来调用父类虚函数的实现。

同名非虚函数，让对象有不同的行为。

##### 私有继承

private继承，只是想要用一些方法，私有继承，不需要指针

私有继承不能转换为基类类型，不能作为基类来使用

避免非虚函数的继承

不要重新定义继承而来的缺省参数值

和合成复用是一样的。如非必须，建议还是使用合成。

### 多继承

一个派生类可以具有多个基类，每个基类可以由不同的继承方式。

继承方式和访问控制方式和单继承一致

派生类拥有所有基类的所有成员

多个基类的同名成员函数/共有变量？首先这个就不好。

基类分解，把基类共有的部分抽象出来

事实上，菱形的也不行，因为还是每个派生类（中间的）有基类，还是冲突。

只继承直接基类的成员

多继承下按多个基类，他们各自的顺序依次进行。ABAC。存储也是，最先调用构造函数的在栈底。

发生名冲突，可以使用基类名::基类成员名来访问。直接访问成员名出错

公共基类有多个副本，实际上需要虚继承来合并

#### 虚继承

virtual public / public virtual

虚基类，会将同名的合并

从is_a 到has_a

没有把A拷贝到BC中，而是BC中有指向同一A的指针。因此没有将A的成员拷贝进来，只是拷贝指针。

如何保证只创建一个A？

虚继承时，虚基类没有特别去构造。现在虚基类不有直接子类调用，而是最新派生的类的构造函数调用，即，由D调用A的构造函数，BC不需要调用A的构造函数

虚基类的构造函数有先非虚基类构造函数进行。

此时由于只有一个A副本，不存在名冲突问题。

虚基类需要在全局设计之后才能使用，要知道整体的继承关系都考虑好。

多继承下多个虚函数表

## Part 3

### 多态

同一个元素在同一论域中可以有多种解释。

从这个角度说，类型转换甚至也是多态。

三种重要的：函数重载（同名函数不同的解释），类属多态：template（针对不同的类型），OO程序设计：虚函数

提高语言的灵活性。同一个元素在不同情况下使用

### 操作符重载

函数重载：同名不同参数，根据不同参数调用不同的函数；静态绑定

操作符针对内置的数据类型，对自定义的数据类型，进行操作符重载。

作用

* 提高可读性
* 提高可扩充

实际上，也是编译期间静态绑定。和函数重载是一样的，一种特殊的函数重载。

歧义控制

只有包含自定义类型的才能重载。

关注一下各种常用的重载

成员函数或全局函数的操作符重载，都可以。

注意全局函数要自定义类型，除了new和delete

操作符重载是针对**自定义类型**而不是**对象**

自增操作符和输出移位操作符

输出移位操作符重载，必须是全局函数，第一个操作数是ostream对象，不是自定义对象，ostream不能拷贝，只能传引用，但是这里不能传const，因为打印的时候是会发生变化的。第二个参数可以是const。必须返回ostream引用，传入的o。这时候传引用，就能够被继续被调用，被当作左值继续使用。一般这里不输出endl。

不建议重载： ->

#### 原则

类的成员函数 带参数的全局函数

遵循单目/双目 优先级和结合性

#### 全局函数

全局函数往往要访问私有成员，一般会把操作符重载声明为友元。

= () [] ->不能作为全局函数进行重载

=等可以类似作为拷贝构造函数。编译器会在类内合成一个相应的版本，所以在类外有也不会被用到。

对双目运算符，最好做成友元的

##### 不能重载 && 和 ||

有短路，重载之后，两个参数都要计算出来才行，破坏了一些原来没问题的程序。违反了约定俗称。

#### 引用和常量的问题

静态函数内变量，每次都是一个右值，但是如果同时使用两个，就不行 if((a * b) && (c * d))

二元操作符返回右值，实际上直接返回临时变量最好，能够应对所有的情况。

这里也不必太担心效率，实际上有返回值优化的优化技术，由于是返回引用，没有返回拷贝，直接把它放在调用的空间里。所以最好在return语句里面去构造，这样效率高。

#### 单目操作符

自增自减

后缀加，哑元参数，区分前缀后缀，由编译器给哑元参数。返回一个临时变量，不是左值。当前行内保持原来的值，返回一个临时变量。