# 服务

## 定义

客户所执行的非持久、无形的体验

客户担任协同提供者

有**无形**的天然属性的一系列活动。

在客户和服务雇员/物理资源和产品（如，电子产品租赁来看电影）/服务提供者系统（主要是 IT 系统）之间的**交互**中发生

提供解决**客户问题**的解决方案。

#### 例子

仓储物流

信息咨询和提供（如法律援助咨询）

金融股票市场

租赁

管理

娱乐

软件开发（主要指包，不是给自己用的，而是应对客户要求完成开发）

……

### 服务和制造

#### 服务模型 vs 制造模式

主要区别于产出

产出差异：服务和产品

##### 主要区别

服务的交互是**双向**的。相同服务提供者提供不同服务时，需要搜集定制化需求，决定提供哪些服务。面向不同的客户提供不一样的服务，满足**个性化**需求。

制造模式是**单向**的，后台提供有形产品，可以放着等用户使用（服务是没有办法“存放”的）。制造模式下，产品是一致的，满足公共的最大需求，不满足独立的特殊需求。制造者和通用用户之间，关系是盲目的，不会为特定用户做出特定的差异。

当然也不是绝对的，制造模式下，用户的反馈以相对长的周期进行反馈。但是这些需求也是只是大规模的，通用的需求，反映共性。

#### 制造和服务的结合

服务和制造并不完全割裂，服务和制造倾向于结合。

制造门槛变低，竞争激烈。需要引入附加价值，也就试图引入服务，这样更好得，定制化需求。

例如，制造汽车是制造模式，如今有各种配置的车，各种颜色，让客户有更多选择，因此也是一种服务的体现，更有竞争力。虽然是看上去丰富的配置和选择，但其实还是单向的，不是由客户提出，再进行制造，而是提供了多种的选择，不支持，比如，其他的颜色、其他的配置，在这种情况下也不能说是单向，可能更高端的车是定制的。终点是定制化体验。

山寨机：某种程度上满足某一类客户的需求。对主流需求只是一部分。以短开发周期、差质量，提供满足小需求。如今主流的产品满足了这些需求。所以如今是越来越定制化的。虽然只是单向的，但仍然是一种向服务的片向。

关注产品提供是否是**单向**的，判断是否是服务。

#### 制造和服务的融合

发展趋势：越来越偏向服务。

定制化家具，更偏向服务。双向模式替代了单向的模式（笔来勾划）

虽然提供有形产品，但是重点是，产物由自己绘制、设计的，由自己的需求精确满足。用户看重自己无形的体验。可以说，这里服务的成分是更多的。

现在，可能不是单纯服务或者单纯制造，而是在两者之间。“服务-产品光谱”

### 服务发展趋势

* 单纯的制造越来越少，服务产业持续增长。例如4s店提供服务、售后等服务。
* 服务越来越复杂、规模越来越大。
  * 银行呼叫中心
  * 提供医疗服务的亿元
  * 复杂企业的管理
  * 电子银行或电子商务
* 引入IT系统
  * 对服务的执行进行支撑
  * 有没有服务雇员均可。如呼叫中心的问答人员是雇员的介入，再如医生也是服务雇员。没有服务雇员，如电子银行，都是标准化的

## 服务系统

服务越来越多，使用IT系统进行支持，实现业务服务这样的系统是服务系统。

业务服务：满足一半消费者对某一方面需求的服务。

由服务系统提供的服务，则该服务是 IT 使能（IT-enable）的服务。（完全不需要IT系统支持的服务，本课程不需要讨论）

* 有IT服务，也含有非IT服务的部分。如，医疗服务，其中有信息系统的支撑，如电子挂号，也有非IT系统的部分，如医生做手术。
* 区别
  * KPIs不一样。关键绩效指标。非IT服务的绩效指标和IT系统的不同。（吞吐量、有效性、响应时间、可靠性等）
  
  * 需求管理不同：服务如何应对客户的需要。这些需要也不同。IT 可能偏向可量化的。
  
  * 变化的步调不同（最大差异）。
  
    IT-enable 的 IT 部分和非 IT 部分的变化步调可能不同
  
    都是IT使能的服务部分时，相关IT系统需要修正时，（如IT系统的更改），当前的变更就会异步。非IT以快的方式变更，IT部分不可能以同样的步调进行修正。

服务系统的本质：软件系统。很多的软件系统都是服务系统。

#### 例子

图书馆检索系统

服务系统类比建筑，每个建筑对某个服务进行支撑。大量的软件系统都是服务系统。

也有 IT 系统不是服务系统。

操作系统不是，word, WPS 不是，不是完全的服务系统。大量的交互系统都可以说是服务系统。

### 组织内的服务系统们

服务系统分成若干个部分。提供给学生/老师

各种服务系统在组织内部提供对应的服务。

可能有统一身份验证的系统

当前的服务系统们，构成了服务系统群。——组织内部的服务系统们组成“建筑群”

构建组织内的服务系统时，可能有各种问题，可能构建得好或差。需要了解，怎样好得构建。

#### 服务系统的问题

* 服务系统的复杂性
  
  * 所有软件系统中比较复杂的。
  * 解决复杂问题，双向交互、定制化需求
  
* 服务系统的灵活性
  
  * 如果已经创建了大量的服务系统，这些服务系统都可能发生变化，业务、技术手段、平台等原因，可能导致变化
  
* 专业化和外包模式

  * 企业组织完成服务系统的构造时，有的任务自己是不专业的。例如，医疗服务的院，其中的绿化、保洁的服务不应该由医生护士完成，而是应该外包。（IT 服务同理），音频解压、人脸识别等，不是具体某企业擅长的技术，所以应该外包，这种情况在原先的情况比较少。

* 计算环境的演化
  
  * 联机、网络、云、智能化平台，演化带来变化
  
* IT专家和业务专家的隔阂
  
  * 以往是让IT专家完全了解业务，这是繁琐的。难以奢求IT专家短时间内正确理解。需求的沟通是困难的。更何况，业务还可能变化（比如技术更新）。IT 专家永远在追赶业务领域专家。
  
* 新增价值和创新功能

* 系列有略微差异的服务系统（产品家族、产品线）

  例如，每个奖学金的申请过程都是大同小异的。

如何利用有限资源建立合适的服务系统？

如何在相对时间长维护服务系统的可用（随着非 IT 领域和业务流程的变化而变化）？

### 命令式（过程式）泛型

软件危机，服务系统的问题更加突出。尤其是，服务系统很多，有限的资源构建需要的服务系统。

传统上，可以应用

* 软年间过程的相关理论、方式、工具。

* 产品簇、产品线

* 泛型

  促进复用

  一步一步提升复用效率

针对计算机的描述完成。对于人的理解并不友好。逻辑单元完成通用的业务流程，在多个场景使用，则使用过程进行复用。

大多数情况下复用的仅仅是计算的**逻辑或流程**，对于**状态**比较薄弱。

### 面向对象的泛型

封装了数据和操作的对象以及对象之间的消息传递描述计算。

封装、继承、多态完成复用。

比如，某功能单元需要复用，则可以通过继承的方式来进行复用。

#### 问题

软件系统随时间发生变化。在面向对象泛型中，可能需要对对象进行重新设计

解决方案：Design Pattern

通过设计模式，在设计时预计软件系统可能的变更，用 DP 来使得应对后面的变化。

Design Pattern 的问题：

* 设计模式是**泛型无关**的

  是否使用设计模式是开发者自由选择的。sb 设计人员，或者限制于成本和资源，可能会没有缺乏这些设计。

  未来得变化应对可能会因为当下的压力而被忽略。

* 设计模式只能在一定程度上缓解，并且设计模式需要付出代价。

  例如，额外的机制和设计，给性能带来负面影响。

面向对象的原理和方法并不能完整得使用。可能单独的系统很好的满足面向对象设计原则，但是企业的大量的服务共同工作时，总体上有问题。

不同服务有同样的模块时，1 不复用，2 直接访问另一个服务，但是当时设计的时候可能没有考虑到要为另一个服务来使用，则需要为新的服务重新设计，这可能导致在原来的服务中出现问题。

服务之间大量的依赖关系，复用时需要修改对方代码，使其不那么规范（使之能够支持本服务），这破坏了对方服务的设计。

这样的修改工作量可能非常大。

问题：对象所抽象的东西仍然是面向计算描述（实现）的

实现就受到两个影响：软件平台；上方接口。二者变化让对象需要修正。

### 基于构件的泛型

把相对稳定的部分抽象出来。

构件：**模块化的、可部署的、可替换**的软件系统组成部分，它**封装**了内部的具体**实现**并对外提供**统一接口**。

比对象的层次高，完成了**独立的功能**，而单独的对象是不能独立完成人物的。

面向**功能单位**处理的

以构件为单位，软件开发过程以构件的创建、构件的管理、复用、组装为应用的基本活动

构件生产、应用组装

好处：

1. 对外提供统一接口，针对特定业务功能抽象，业务接口极少发生变更

   例如，统一认证功能，无论外部使用环境如何（图书馆、教室……），当前接口统一发挥其功能，内部具体实现如何变化都不会影响接口，变化范围局限在构件内部。构件可以在不同场景下随时间稳定

2. 构件的功能单位，比整个业务逻辑小很多

   容易进行需求分析，更容易实现高质量软件。

业务领域专家来使用构件， IT 专家只需要开发。部分解决了 IT 专家和业务专家的隔阂问题。

类比于应用组装。工厂不需要知道构件生产出来之后如何组建成“房子”。

按照标准方式互联，由构建的标准接口定义，短时间内搭建完成。

特点

1. 构建过程，设计人员不需要知道构件内部如何实现、开发流程如何，只需要知道构件能够满足需求。

   复用的粒度变大，不再是使用“砖头”，而是使用“墙”。剩下得由业务领域专家完成。避免了繁琐、冗余的交流来完成信息化（业务转化为 IT）
   
   流程开发和构件开发分开。

##### 对比构件和面向对象

|                      | 基于构件                                                     | 面向对象                                                     |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 抽象视角             | 对客观世界的实体或者实体联合提供的功能和服务的建模；仅仅关注实体的功能和服务 | 对客观世界的基本实体的抽象，强调对实体的对应及对实体的建模；设计实体的静态属性特征 |
| 可复用程度和复用机制 | 以组合的方式实现复用                                         | 以继承的方式实现复用                                         |
| 粒度不同             | 大                                                           | 小                                                           |

构件和对象也不是完全冲突的，很多情况下，大粒度的构件内部可以以 OO 来实现，对外进行合理封装完成相关功能，拥有统一接口，让构件之间无缝连接。

### 面向服务的泛型

通过网络来实现构件的调用和访问，则称为**服务**

服务：自治、开放、自描述、与实现无关的网络构件。

#### 自治

对于功能的抽象，单独完成任务，不依赖于其他部件来完成工作

#### 开放

来源于不同公司的构件接口可能不是统一的。服务的定义要求开放的，即只要遵循一般的规范、协议、标准，当前的服务的统一接口则应该跨公司、跨平台，全球可以统一调用。

在构件基础上更加提高了复用性

#### 自描述

和开放相关，通过网络，如果不加限制，则所有人都应该能够调用该服务。需要让别人知道这个服务提供了什么功能，有什么约定的条件。

应该服务自己描述自己完成的任务。

#### 与实现无关

和构件一致。

#### 特征

本来构件局限于一个提供商，如果再想引用其他公司，则可能构件不兼容。

引入网络构件之后，所有东西通过标准方式网络互联，共享的方式不是共享代码、设计、实现，而是共享**计算**

不需要将代码提供给需要复用的人。

#### 开发流程

服务的构建、服务的组装。通过分析流程看功能有什么，每个环节需要哪些服务，组装之后完成完整的流程实现客户需求。

生产由 IT 专家，只需要考虑更容易理解的编程单元

组装由业务专家，只需要完成流程。

##### 服务（第一阶段）

* 功能相关（和流程无关）
* 简单、相对稳定
* 由 IT 专家开发

##### 过程（第二阶段）

复杂、多变、灵活，非IT服务领先的变化部分

* 应用相关
* 复杂多变
* 由业务专家开发
* 可以被封装为服务

大家各司其职，相互之间不需要过多的不必要的交流。面向对象下，业务流程、逻辑都需要 IT 专家完成，现在只业务专家只需要组装封装良好的服务进行组装即可。最大程度上节约资源

#### 节约资源

* 一个 IT 专家开发的服务，在不同业务中可以进行复用，因为按照标准接口进行开发的
* 由商务专家组装过程时，不需要 IT 专家的支持。相对于快速变化的服务系统非常合适。

## 服务生态系统

把面向服务的泛型推广到企业中。

### 服务组合

面向服务的应用逻辑，所有业务逻辑都通过服务和服务组合来实现，规范是面向服务的设计原则。

若干个相关的服务功能拼装，实现更大的业务逻辑，满足业务需求。

* 服务组合由多个装配在一起的服务所构成，用以提供对业务任务或者过程进行实现的功能。

服务组合和服务没有冲突，组合的服务也可以对外提供服务。

* 和调用者无关，和系统的软件环境无关的企业资源，在任何可能的上下文，只要完成服务生成的功能，都可以调用对应的资源，不随着软件生命周期消亡而消亡。

例如，某个系统中的类，在这个系统不需要，则类也没用。但是在服务系统中，比如借书不存在了，但是打印、统一认证的服务仍然有用。

不同的服务组合可能调用同一个服务。

### 服务库存

组织或者组织的合理部分边界内，一组独立标准化并治理的完备服务。

企业组织中或者其中部分的所有服务的集合。

可能的构造方式：按照服务的模型分层。

按照服务的性质和完成的任务区分 

* 应用服务层
* 业务服务层
* 编排服务层

前两层必要。

构建前，服务库存的蓝图应该**已经设计**。

#### 应用服务层

紧密和实现相关的较小功能单元抽线的服务。

可能和具体的某个 IT 任务相关。

例如，打印，可能有不同的功能

把和技术紧密相关的服务抽象出来，其他的服务需要的时候可以进行调用，其他服务不需要处理和实现、细碎任务

#### 业务服务层

主要的、最常见的服务。

直接满足调用者、消费者需求的服务。

按照实现、设计的特征拆分为：以业务为中心的业务服务（任务服务）、以实体为中心的业务服务（实体服务）

任务服务面向业务流程

业务服务和应用服务，可以用单纯的简单服务实现，也可以通过服务组合来完成，服务中调用其他服务完成由其他服务实现的功能。

#### 编排服务

可选的服务层。

服务组合的一种实现：一般的编程环境中，如果选择了某个平台来对服务组合实现，可能使用本地代码调用需要的子服务，通过标准接口调用。用服务组合来调用服务，则当前的业务流程不是通过本地代码（Native Code）来完成的。用平台中立的语言，通常基于 XML ，描述服务组合的逻辑，可以动态编译执行，方便领域专家改写，甚至可以通过 GUI 来进行。

### 服务库存演化的阶段

不可能一开始就把所有的服务开发完毕，一般按需开发。

* 阶段 1 ：初始服务交付项目

  开发过程中，针对需要的服务，进行优先开发。

  当前服务并不是隶属于当前应用、软件系统，因为服务是**中立**的，**独立**于当前软件系统，独立于调用它的服务系统或应用

  这些服务被放置在服务库存中

* 阶段 2 ：混合应用和成长中的服务库存

  服务的数量持续增长，服务组合的可能性也持续增长，但是服务库存尚未完成

  服务开发要求中立的方式把所有功能封装，所以新的系统只需要在服务库存中找到、直接调用现有的服务，然后加入新的服务

  新的服务加入**并非无序**的，因为服务库存之前就已经建立，只是知道还没有写，需要的时候再写。

  服务组合的可能性和复杂程度提升

* 阶段 3 ：服务库存基本构建完毕

  服务库存的演化基本完成，随着服务库存的增长，潜在的服务组合的复杂度随之提升。

  可能新的系统，绝大部分的服务都是已经构建的。甚至可能有的系统不需要任何额外开发，只需要按照业务流程拼装服务。

#### 龙卷风模型

越往后累计的“资产”越多，需要完成特定任务的代价越少

### 服务生态系统

服务库存按照面向服务的方式进行良好规划和设计、经过长时间演化、已经基本完备，则该组织的服务系统均已合理地转向面向服务的实现，则该组织的服务生态系统就被构建按了

包括分析、设计、实现、治理、演化。

治理：服务是共享计算，任何需要使用服务，通过网络使用标准接口调用，服务提供计算资源来计算，治理说的是如何通过有限的计算资源尽量满足所有人的需求。

演化：服务实现落后，不能满足性能、功能需求，则可能需要重新设计，这就是演化。兼容性演化（接口不变，后台实现变化），非兼容性演化（标准接口也发生变化，一般只在业务逻辑有很大扩充的情况下进行，比如十年前的统一认证没有考虑指纹认证，接口不能满足）。

##### 从消费者角度出发：

* 可以被同时、独立调用的，用以满足消费者需求的服务，称为**垂直服务**

  调用直接满足当前需求。

* 垂直服务可以由多个可重复的跨领域的公共服务所构成，这些公共服务被称为**水平服务**

  被垂直服务调用，不直接被消费者直接调用

  二者唯一标准是否是在某个特定场景被消费者直接调用。

* 二者不是互斥的

  可能在不同的场景下不同

  例如，发送 E-mail 在某场景下是垂直服务，但是可能如批改作业并通知，包含了发送 E-mail 的环节，则这就是水平服务

应用、业务、编排是另外的分类体系。

### 例子

消费者双向交流，不同的服务领域给出垂直服务，水平服务层中，提供垂直服务需要组合的子服务，其中可能是业务服务和应用服务。

消费者可以**穿透**垂直服务，调用水平服务的特定服务，则认为那个水平服务也兼具了垂直服务，所以两层划分并不是固定、明显的。

另外，服务可能有自开发服务和外包服务。这样在面向对象中，外包之后也需要对方完成本地的部署，在运维阶段没什么差异，但是在服务生态系统中，自开发服务可能企业内部有服务器环境，而外包服务很可能是没有实际的运行环境，只是能拥有通过网络对别人的服务访问的权力，也不需要管环境，只需要调用。这样，企业的边界就显得不是那么牢不可破了。

## 面向服务的计算

* 从泛型角度

  面向服务的计算（SOC）是一种新型计算泛型。该泛型以服务作为基本概念，以支持快速和低成本开发，和异构环境中分布式应用的灵活组合。

* 从架构角度

  面向服务的计算是一组使用面向服务的架构（SOA）来表达计算的概念、原理和方法。再面向服务的架构中，使用带有标准接口的独立构件服务来构造软件应用

* 从服务角度出发

  为了再业务服务和 IT 服务之间建立连接，并进一步改进业务服务，面向服务的计算行啊了运用计算和信息技术建模、创建、操作和管理业务服务的科学和技术

  以服务作为抽象对象

* 从软件工程角度出发

  采用工程化方法，以服务作为基本抽象元素，对服务系统进行分析、设计、开发、测试、部署、管理等活动所涉及的理论、技术和方法。

### 软件应用构造阶段

分析、涉及、事先、测试、部署、管理都和以往的软件工程的对应阶段相匹配

### 面向服务的目标

* 技术目标

  * 灵活程度

    灵活多变，快速构造

  * 鲁棒性

    特定部分出问题，快速定位、替换，无缝切换

  * 可扩展性

    全新特性引入到服务生态系统，灵活快速低代价引入

  * 业务和技术的相关性、灵活对照

    处理业务专家和 IT 专家交流

  * 可重用性和复用

    其他的四个属性都是基于此，因为把最值得复用的、最稳定的计算单位抽象了（服务），构造服务库，采用拼装的方式满足多种多样、流程多变的业务应用。

* 商务（业务）目标

  * 软件供应商中立

    某些服务可以外包给别人。中立的标准化通用接口，让任何来源的服务都可以无缝组合到服务组合

  * 潜在可互操作性

    生态系统中，很多相应的服务系统，之前天然具备可互操作性，避免信息孤岛、数据集成、应用集成

  * 组织化的灵活

    当前企业也可以实现面向服务的架构，避免以人事来拆分，而是以服务为单位进行组织

  * 联邦概念

    提供服务的服务提供商，用联盟的方式进行组合，商业成本下降

  * 降低 IT 成本

    浪费在重复开发的成本被节约

  * 业务和技术的一致性

    交流方便，以面向服务的方式让两种专家相互交流

  * 投资回报率增加 ROI

这些指标并非独有，传统上也是有的，但是在 SOC 下更容易达成。

## 面向服务 vs. 面向对象

| 特点               | OOC                                                          | SOC                                                          |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 方法论             | 通过定义紧耦合的类进行应用开发                               | 通过定义**松耦合**的服务进行应用开发，将服务组装成可执行的应用 |
|                    | 应用架构为基础的继承关系的层次式架构                         | 从系统模型到服务模块，从服务抽象定义到服务实现的绑定（理论上是自顶向下的拆分） |
|                    | 从构造函数——通过类或者模型——到系统设计（自底向上）           | 通过搜索获得可用的服务实现（可以设计时不知道谁提供，运行时绑定服务的设计和实现 ） |
| 抽象和协作层次     | 一个团队负责应用的开发，负责整个生命周期                     | 开发任务分成三个独立放承担：应用程序开发者、服务提供方、服务代理 |
|                    | 开发者必须了解应用领域知识和编程                             | 应用程序开发者需要了解应用逻辑，但是不需要了解具体服务如何实现 |
|                    |                                                              | 服务提供方和服务代理需要编程能力，但是不需要了解使用服务的应用 |
| 代码共享和复用     | 通过类成员继承和库函数实现。库函数在编译时引入，且往往是平台相关的。共享复用粒度不高，且在编译时就完成的。 | 代码在服务层次复用。服务使用标准的结构，发布在 Internet 库中。平台无关，以远程调用计算能力进行。服务代理支持系统的服务共享。（系统之间可以共享、复用服务） |
| 动态绑定和重新组合 | 在运行时将名称和方法进行关联。方法必须在应用部署前链接到可执行的代码。即部署之后没有重新组合、动态绑定的能力。 | 在运行时将服务调用和服务进行动态绑定。可以在应用部署之后再进行服务。可以在调用时寻找服务提供者提供了概念意义上的服务，由服务中介提供 |
| 重组               | 在设计时决定导入的组件。设计之后完全固定了，部署实现之后几乎无法重组。 | 可以动态改变应用系统中服务的组合关系，以及服务定义与服务实现之间的绑定关系，即实现动态得添加、修改、删除各个服务结点。服务作为基本抽象单位，组装为复杂得业务流程。服务本质上不隶属于特定应用，不隶属于特定业务流程，可以同时服务于若干业务流程、服务系统，因此有必要时可以在运行时进行动态操作。 |
| 组件通讯和接口     | 和平台、语言有关，例如， C++ 程序难以直接和 Java 程序通信。局限在特定平台中，我们倾向于在一个平台、利用一个语言进行 | 和平台、语言无关。组件之间通过标准协议通信，例如 XML，WSDL，SOAP。抽象了标准连接接口，利用平台中立的接口进行描述。可能同一应用不同服务实在不同平台上，按照适合的方式进行设计、开发、部署。面向服务的方式标准化接口封装，互相之间无缝连接，这在面向对象中间，跨平台是比较麻烦的 |
| 系统维护           | 用户需要时常升级软件，且在执行升级时，应用必须停止。         | 通过互联网升级系统，因为服务多运行在远程服务器上，用户通过互联网进行访问，维护对用户透明。服务的接口本质上可以被替换，谁来实现并不重要，因此可以后台无缝切换的别的服务，调用人员使用时可以在线、无缝得切换、维护、升级。 |
| 可靠性             | 在设计时决定可靠性得方法。由于没有动态，因此不能像服务一样动态得找。 | 对于服务提供者，每个服务相对简单，更加可靠。对于应用程序存在多个满足同一需求得服务，可用过将故障服务的结点断开并重新绑定到备选服务节点上，获得不间断的应用系统。运行时态决定调用，多个实现可以动态切换，可以保证总有服务提供者提供服务。 |
| 软件拥有           | 软件作为产品销售，为用户所拥有。卖断式。                     | 软件存在并执行于独立的服务提供商得设备上，用户按照每次对服务使用付费，而不是按照软件产品付费。产品并非代码及其衍生物，而是“计算的能力”。 |

### 设计角度的差异

| 特点   | OOC                                                          | SOC                                                          |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 耦合   | 提倡重用和松耦合，但是预先定义的类依赖导致更多的对象紧密绑定 | 服务的松耦合由功能和服务合约给定                             |
| 粒度   | 为支持不同规模的任务，支持细粒度接口（API）。支持分析设计、实现编程，不同对象的每个接口都可能是不同的，有的可能粒度比较高，有的粒度比较小 | 鼓励粗粒度的接口（服务描述），通讯消息中包含尽可能多的任务相关消息。面向设计的方式提供，粒度可能不一样，但是相对不那么悬殊 |
| 作用域 | 对象作用域更小，更有针对性，往往基于一个软件系统。           | 服务作用域显著不同，往往基于一个服务生态系统。               |
| 前瞻性 | 鼓励处理逻辑与数据的绑定从而产生对象。状态、逻辑封装为对象，逻辑和状态的切换面向实现，只解决当下问题，如果需要进行修改、实现，会让面向对象的计算环境处理前瞻性问题能力比较弱。 | 鼓励创建互动无关的、由消息驱动的服务 。计算单位从过程上升到服务，服务和使用的环境上下文无关，只对它完成的功能抽象，对未来、过去、全局抽象，相对而言， SOC 更加容易兼容到未来的变化，它不局限于解决当下问题，而是解决整个企业中的功能的实现。 |
| 状态性 | 数据和逻辑的绑定，导致带状态的对象。带状态并不是服务所拥有的特性。 | 服务尽可能保持无状态性。即每次调用，表现得业务逻辑都一样。不带状态得服务更容易预测，更容易预分配相关资源。 |
| 组合   | 在支持对象组合得同时也支持对象的继承，从而导致紧耦合。组合以对象 | 支持松耦合服务的组合。用服务的组装来进行组合，这优于 OOC     |

### 实现角度的差异

可能可以通过面向对象的方式描述 Web Service 来支持一个概念服务。

服务是和实现无关的网络构件，自然可以通过 OO 来描述服务内部的实现。

设计时，通过面向服务的方式对接口进行设计，而接口内部的实现可以用 OO 来进行。这是非常常见、主流的方式。