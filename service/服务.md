# 服务

## 定义

客户所执行的非持久、无形的体验

客户担任协同提供者

有**无形**的天然属性的一系列活动。

在客户和服务雇员/物理资源和产品（如，电子产品租赁来看电影）/服务提供者系统（主要是 IT 系统）之间的**交互**中发生

提供解决**客户问题**的解决方案。

#### 例子

仓储物流

信息咨询和提供（如法律援助咨询）

金融股票市场

租赁

管理

娱乐

软件开发（主要指包，不是给自己用的，而是应对客户要求完成开发）

……

### 服务和制造

#### 服务模型 vs 制造模式

主要区别于产出

产出差异：服务和产品

##### 主要区别

服务的交互是**双向**的。相同服务提供者提供不同服务时，需要搜集定制化需求，决定提供哪些服务。面向不同的客户提供不一样的服务，满足**个性化**需求。

制造模式是**单向**的，后台提供有形产品，可以放着等用户使用（服务是没有办法“存放”的）。制造模式下，产品是一致的，满足公共的最大需求，不满足独立的特殊需求。制造者和通用用户之间，关系是盲目的，不会为特定用户做出特定的差异。

当然也不是绝对的，制造模式下，用户的反馈以相对长的周期进行反馈。但是这些需求也是只是大规模的，通用的需求，反映共性。

#### 制造和服务的结合

服务和制造并不完全割裂，服务和制造倾向于结合。

制造门槛变低，竞争激烈。需要引入附加价值，也就试图引入服务，这样更好得，定制化需求。

例如，制造汽车是制造模式，如今有各种配置的车，各种颜色，让客户有更多选择，因此也是一种服务的体现，更有竞争力。虽然是看上去丰富的配置和选择，但其实还是单向的，不是由客户提出，再进行制造，而是提供了多种的选择，不支持，比如，其他的颜色、其他的配置，在这种情况下也不能说是单向，可能更高端的车是定制的。终点是定制化体验。

山寨机：某种程度上满足某一类客户的需求。对主流需求只是一部分。以短开发周期、差质量，提供满足小需求。如今主流的产品满足了这些需求。所以如今是越来越定制化的。虽然只是单向的，但仍然是一种向服务的片向。

关注产品提供是否是**单向**的，判断是否是服务。

#### 制造和服务的融合

发展趋势：越来越偏向服务。

定制化家具，更偏向服务。双向模式替代了单向的模式（笔来勾划）

虽然提供有形产品，但是重点是，产物由自己绘制、设计的，由自己的需求精确满足。用户看重自己无形的体验。可以说，这里服务的成分是更多的。

现在，可能不是单纯服务或者单纯制造，而是在两者之间。“服务-产品光谱”

### 服务发展趋势

* 单纯的制造越来越少，服务产业持续增长。例如4s店提供服务、售后等服务。
* 服务越来越复杂、规模越来越大。
  * 银行呼叫中心
  * 提供医疗服务的亿元
  * 复杂企业的管理
  * 电子银行或电子商务
* 引入IT系统
  * 对服务的执行进行支撑
  * 有没有服务雇员均可。如呼叫中心的问答人员是雇员的介入，再如医生也是服务雇员。没有服务雇员，如电子银行，都是标准化的

## 服务系统

服务越来越多，使用IT系统进行支持，实现业务服务这样的系统是服务系统。

业务服务：满足一半消费者对某一方面需求的服务。

由服务系统提供的服务，则该服务是 IT 使能（IT-enable）的服务。（完全不需要IT系统支持的服务，本课程不需要讨论）

* 有IT服务，也含有非IT服务的部分。如，医疗服务，其中有信息系统的支撑，如电子挂号，也有非IT系统的部分，如医生做手术。
* 区别
  * KPIs不一样。关键绩效指标。非IT服务的绩效指标和IT系统的不同。（吞吐量、有效性、响应时间、可靠性等）
  
  * 需求管理不同：服务如何应对客户的需要。这些需要也不同。IT 可能偏向可量化的。
  
  * 变化的步调不同（最大差异）。
  
    IT-enable 的 IT 部分和非 IT 部分的变化步调可能不同
  
    都是IT使能的服务部分时，相关IT系统需要修正时，（如IT系统的更改），当前的变更就会异步。非IT以快的方式变更，IT部分不可能以同样的步调进行修正。

服务系统的本质：软件系统。很多的软件系统都是服务系统。

#### 例子

图书馆检索系统

服务系统类比建筑，每个建筑对某个服务进行支撑。大量的软件系统都是服务系统。

也有 IT 系统不是服务系统。

操作系统不是，word, WPS 不是，不是完全的服务系统。大量的交互系统都可以说是服务系统。

### 组织内的服务系统们

服务系统分成若干个部分。提供给学生/老师

各种服务系统在组织内部提供对应的服务。

可能有统一身份验证的系统

当前的服务系统们，构成了服务系统群。——组织内部的服务系统们组成“建筑群”

构建组织内的服务系统时，可能有各种问题，可能构建得好或差。需要了解，怎样好得构建。

#### 服务系统的问题

* 服务系统的复杂性
  
  * 所有软件系统中比较复杂的。
  * 解决复杂问题，双向交互、定制化需求
  
* 服务系统的灵活性
  
  * 如果已经创建了大量的服务系统，这些服务系统都可能发生变化，业务、技术手段、平台等原因，可能导致变化
  
* 专业化和外包模式

  * 企业组织完成服务系统的构造时，有的任务自己是不专业的。例如，医疗服务的院，其中的绿化、保洁的服务不应该由医生护士完成，而是应该外包。（IT 服务同理），音频解压、人脸识别等，不是具体某企业擅长的技术，所以应该外包，这种情况在原先的情况比较少。

* 计算环境的演化
  
  * 联机、网络、云、智能化平台，演化带来变化
  
* IT专家和业务专家的隔阂
  
  * 以往是让IT专家完全了解业务，这是繁琐的。难以奢求IT专家短时间内正确理解。需求的沟通是困难的。更何况，业务还可能变化（比如技术更新）。IT 专家永远在追赶业务领域专家。
  
* 新增价值和创新功能

* 系列有略微差异的服务系统（产品家族、产品线）

  例如，每个奖学金的申请过程都是大同小异的。

如何利用有限资源建立合适的服务系统？

如何在相对时间长维护服务系统的可用（随着非 IT 领域和业务流程的变化而变化）？

### 命令式（过程式）泛型

软件危机，服务系统的问题更加突出。尤其是，服务系统很多，有限的资源构建需要的服务系统。

传统上，可以应用

* 软年间过程的相关理论、方式、工具。

* 产品簇、产品线

* 泛型

  促进复用

  一步一步提升复用效率

针对计算机的描述完成。对于人的理解并不友好。逻辑单元完成通用的业务流程，在多个场景使用，则使用过程进行复用。

大多数情况下复用的仅仅是计算的**逻辑或流程**，对于**状态**比较薄弱。

### 面向对象的泛型

封装了数据和操作的对象以及对象之间的消息传递描述计算。

封装、继承、多态完成复用。

比如，某功能单元需要复用，则可以通过继承的方式来进行复用。

#### 问题

软件系统随时间发生变化。在面向对象泛型中，可能需要对对象进行重新设计

解决方案：Design Pattern

通过设计模式，在设计时预计软件系统可能的变更，用 DP 来使得应对后面的变化。

Design Pattern 的问题：

* 设计模式是**泛型无关**的

  是否使用设计模式是开发者自由选择的。sb 设计人员，或者限制于成本和资源，可能会没有缺乏这些设计。

  未来得变化应对可能会因为当下的压力而被忽略。

* 设计模式只能在一定程度上缓解，并且设计模式需要付出代价。

  例如，额外的机制和设计，给性能带来负面影响。

面向对象的原理和方法并不能完整得使用。可能单独的系统很好的满足面向对象设计原则，但是企业的大量的服务共同工作时，总体上有问题。

不同服务有同样的模块时，1 不复用，2 直接访问另一个服务，但是当时设计的时候可能没有考虑到要为另一个服务来使用，则需要为新的服务重新设计，这可能导致在原来的服务中出现问题。

服务之间大量的依赖关系，复用时需要修改对方代码，使其不那么规范（使之能够支持本服务），这破坏了对方服务的设计。

这样的修改工作量可能非常大。

问题：对象所抽象的东西仍然是面向计算描述（实现）的

实现就受到两个影响：软件平台；上方接口。二者变化让对象需要修正。

### 基于构件的泛型

把相对稳定的部分抽象出来。

构件：**模块化的、可部署的、可替换**的软件系统组成部分，它**封装**了内部的具体**实现**并对外提供**统一接口**。

比对象的层次高，完成了**独立的功能**，而单独的对象是不能独立完成人物的。

面向**功能单位**处理的

以构件为单位，软件开发过程以构件的创建、构件的管理、复用、组装为应用的基本活动

构件生产、应用组装

好处：

1. 对外提供统一接口，针对特定业务功能抽象，业务接口极少发生变更

   例如，统一认证功能，无论外部使用环境如何（图书馆、教室……），当前接口统一发挥其功能，内部具体实现如何变化都不会影响接口，变化范围局限在构件内部。构件可以在不同场景下随时间稳定

2. 构件的功能单位，比整个业务逻辑小很多

   容易进行需求分析，更容易实现高质量软件。

业务领域专家来使用构件， IT 专家只需要开发。部分解决了 IT 专家和业务专家的隔阂问题。

类比于应用组装。工厂不需要知道构件生产出来之后如何组建成“房子”。

按照标准方式互联，由构建的标准接口定义，短时间内搭建完成。

特点

1. 构建过程，设计人员不需要知道构件内部如何实现、开发流程如何，只需要知道构件能够满足需求。

   复用的粒度变大，不再是使用“砖头”，而是使用“墙”。剩下得由业务领域专家完成。避免了繁琐、冗余的交流来完成信息化（业务转化为 IT）
   
   流程开发和构件开发分开。

##### 对比构件和面向对象

|                      | 基于构件                                                     | 面向对象                                                     |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 抽象视角             | 对客观世界的实体或者实体联合提供的功能和服务的建模；仅仅关注实体的功能和服务 | 对客观世界的基本实体的抽象，强调对实体的对应及对实体的建模；设计实体的静态属性特征 |
| 可复用程度和复用机制 | 以组合的方式实现复用                                         | 以继承的方式实现复用                                         |
| 粒度不同             | 大                                                           | 小                                                           |

构件和对象也不是完全冲突的，很多情况下，大粒度的构件内部可以以 OO 来实现，对外进行合理封装完成相关功能，拥有统一接口，让构件之间无缝连接。

### 面向服务的泛型

通过网络来实现构件的调用和访问，则称为**服务**

服务：自治、开放、自描述、与实现无关的网络构件。

#### 自治

对于功能的抽象，单独完成任务，不依赖于其他部件来完成工作

#### 开放

来源于不同公司的构件接口可能不是统一的。服务的定义要求开放的，即只要遵循一般的规范、协议、标准，当前的服务的统一接口则应该跨公司、跨平台，全球可以统一调用。

在构件基础上更加提高了复用性

#### 自描述

和开放相关，通过网络，如果不加限制，则所有人都应该能够调用该服务。需要让别人知道这个服务提供了什么功能，有什么约定的条件。

应该服务自己描述自己完成的任务。

#### 与实现无关

和构件一致。

#### 特征

本来构件局限于一个提供商，如果再想引用其他公司，则可能构件不兼容。

引入网络构件之后，所有东西通过标准方式网络互联，共享的方式不是共享代码、设计、实现，而是共享**计算**

不需要将代码提供给需要复用的人。

#### 开发流程

服务的构建、服务的组装。通过分析流程看功能有什么，每个环节需要哪些服务，组装之后完成完整的流程实现客户需求。

生产由 IT 专家，只需要考虑更容易理解的编程单元

组装由业务专家，只需要完成流程。

##### 服务（第一阶段）

* 功能相关（和流程无关）
* 简单、相对稳定
* 由 IT 专家开发

##### 过程（第二阶段）

复杂、多变、灵活，非IT服务领先的变化部分

* 应用相关
* 复杂多变
* 由业务专家开发
* 可以被封装为服务

大家各司其职，相互之间不需要过多的不必要的交流。面向对象下，业务流程、逻辑都需要 IT 专家完成，现在只业务专家只需要组装封装良好的服务进行组装即可。最大程度上节约资源

#### 节约资源

* 一个 IT 专家开发的服务，在不同业务中可以进行复用，因为按照标准接口进行开发的
* 由商务专家组装过程时，不需要 IT 专家的支持。相对于快速变化的服务系统非常合适。