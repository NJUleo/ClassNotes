# 设备管理

#### 目标

##### 解决速度不匹配

提高设备利用率

- 动态分配
- 设计数据缓冲技术
- 独占型设备改造成虚拟可共享的设备

##### 屏蔽设备物理细节和操作过程

抽象为裸设备

抽象为设备文件，对文件的读写变成对设备的读写

#### 设备分类

##### 字符设备

##### 块设备

快一点

和页的尺寸有所联系

##### 网络设备

有线、无线网卡等

### IO的控制方式

设备控制器，电子部件的设置

系统直接与控制器交互，而不是机械部分，控制器完成具体的内容

#### 设备控制器

##### 功能

接受识别CPU的命令

数据交换

记录状态信息

多台设备，识别设备地址

##### 组成

###### 主机侧

数据缓冲寄存器

状态控制寄存器

地址译码和IO控制逻辑，与计算机内存相互连接

###### 操作设备侧

### IO控制三种基本方式

#### 轮询

发送命令之后，轮询IO结果

轮询到设备就绪

执行内存数据交互

等待操作之后再操作

效率低下

#### IO中断控制

发送IO命令由设备控制器完成，就绪后发生中断，CPU响应之后，通过中断处理进行IO

外围设备和CPU有一定的并行性。

异步IO，继续执行当前进程。不等，可以并行

同步IO，中断挂起，执行其他的进程。需要等，后面的程序依赖与IO结果。

#### DMA直接存储器访问

IO中断时，设备控制器管理的缓冲和内存交互仍然需要中断

对于块设备，让DMA代替处理器，控制主存和设备控制器之间的数据交换

中断驱动的一种升级，内存操作由DMA代理，不由CPU直接管理

频繁访问的告诉外设，能加大并行性

DMA完成传送之后，中断处理器

实现内存的数据交换，要使用总线

CPU和DMA可能同时竞争总线。

###### 总线窃取

DMA周期窃取主存，在处理器的一些周期中，CPU不使用内存，DMA可以利用这些周期进行周期窃取，实现共用总线

只能在物理层次上实现并行

DMA的实现是作为硬件考虑的问题，实际上不是操作系统的范畴，操作系统只会考虑到指令集的层次上，像是DMA和CPU之间共用总线的问题，是硬件厂商决定的。对于流水线式的CPU，DMA窃取总线方式肯定是行不通的，有另外的方法。

###### 停止CPU访问内存

###### 周期挪用

不同的硬件厂商产生不同的DMA内存访问机制，这并不是操作系统的讨论范畴。

### IO通道

逻辑上的IO任务，进一步提高并行性

通过处理器、通道、控制器、设备四级连接

通道可控制多台同类或不同类的设备

处理器不再执行IO命令，改为在主存中组织通道程序，是逻辑的并行

Linux Device Drivers

### 总线

计算机的总线连接能够导致计算机速度的巨大差别

主要处理IO速度不匹配的问题

各种不同速度的外设竞争总线。合理设计总线，充分并性，提高系统的效率。

#### 单总线模型

结构简单

多设备时总线压力大，低速的设备大大占用总线

#### 三级总线模型

CPU总线

系统总线

扩展总线

不同的总线并性处理

有效把电子设备和机械设备进行分离，提高了性能

不同的IO数据差距大的情况没有办法处理

#### 南桥北桥多级总线

分割快慢IO设备

北桥速度更快一些，连接处理器和主存总线，通过桥接接口连接南桥芯片，连接PCI总线和E(ISA)总线。GPU连接在PCI总线。

#### 基于通道的服务器总线模型

不同IO通道，通过下一级总线连接设备控制器，再通过下一级总线连接设备。

比南北桥更适合传输。

### IO软件

#### 设计目标

高效率：改善设备效率，尤其是磁盘IO效率

通用性：统一的标准管理设备，提供统一接口

系统性能的瓶颈主要在IO处理。（只要不是纯计算的进程）

#### 设计思路

分层思想

底层软件屏蔽硬件细节，高层软件提供统一接口

IO设备抽象为文件来管理，标准化的访问接口，用户友好。

#### 考虑问题

* 设备无关性
  * 用户IO与具体设备无关
* 出错处理
  * 能被底层处理得错误就由底层处理并屏蔽
* 同步/异步处理
  * 能不同步的，尽可能异步，提高并性度。
  * 异步的时候，数据上的依赖要考虑到
* IO缓冲技术
  * 提高IO吞吐率
  * 高速存储为低速设备提速，使用磁盘高速设备。

#### 层次结构

IO硬件

IO中断处理程序	处理IO中断，报告错误，唤醒驱动程序。

IO驱动程序 具体设备的IO中断处理

独立于设备的IO软件 设备的命名 保护 阻塞 缓冲 分配 跟踪，逻辑性更高

用户空间IO软件	通用的IO系统调用，IO格式化(fprintf), SPOOLing

##### 设备驱动程序

用户空间逻辑上的IO请求，转换为物理上的IO操作。

监督设备是否正确执行，访问数据缓冲区

### IO缓冲

#### 目的

减少IO次数

写操作不是直接写回而是写入缓冲区，避免大量的IO次数。同一个扇区的，多次修改，一次IO。先写入缓冲区，缓冲区批量写回磁盘。副作用，只写入缓冲区而没有写入磁盘文件，造成错误。读文件的时候要先open，用完之后要close，实际上close中有将缓冲区写入磁盘，让关闭之前已经发生的写操作持久化。

## 设备独立性

静态：当作业执行对设备申请时，指定某物理设备。（微型计算机的OS常用）

如果恰好某一个时故障，即使有同类设备，也不能进行，需要更加灵活的分配方式。

动态（设备独立性）：作业不指定实际物理设备，而是制定逻辑设备，由操作系统建立进程逻辑设备和物理设备的映射。运行时动态绑定物理设备。

操作系统要划分逻辑设备和物理设备，实现其中的映射。

#### 优点

应用程序与物理设备无关，解除进程与具体物理设备的耦合。

应对IO故障

分配灵活，有效使用，多道程序设计的思想。

## 独占型外围设备分配

一次只能一个进程独立使用

大多数外围设备都是独占型

先申请再使用再归还。

磁盘 光盘库 不是外围设备。

### 静态分配

**运行前**申请外围设备

运行中不再进行调整

防止运行中进程死锁

设备利用率低下，在进程中（在内存中，三个基本状态的周期中）不是每时每刻都在用这个设备。设备闲置却被占用

### 动态分配

随用随申请

灵活性高，减少空闲

#### 死锁问题

解决死锁就需要剥夺资源，这意味着该进程前面的一些工作是无效的

并不知道，处理器分配的时候，比如时间片轮转，它在哪停下来，处理器现场发生跳转，被其他程序抢占。如果在中间区，恰好发生了处理器的抢占，两个进程都进入阻塞队列，系统发生死锁，就绪队列空，CPU闲置。

互斥、独占型设备的状况，每个进程都不能获得自己需要的所有设备，循环等待。

#### 建立设备分配的数据结构

##### 设备表 

登记所有的物理设备

##### 设备类表

实现设备独立性

申请的时候是申请设备类表的逻辑设备

## 磁盘的

### 物理结构

磁盘结构 工作方式 读写时间

#### 磁盘结构

多个盘片，每篇2面。

相同位置、不同盘面：柱面

磁道长度不同，但是扇区一致。

相邻扇区组合为簇

物理块地址：柱面号、磁头号（盘面）、扇区号；磁头、柱面、扇区（扇区从1开始）0面0道1扇区

读写数据，磁头定位响应磁道（柱面）

寻道 旋转 选择磁头号，传递数据

在虚存方式下，缺页导致IO操作。硬件上需要高速随机存储的外部存储设备。

#### 磁盘IO传送时序

等待设备 等待通道 寻道 旋转 数据传送

### 磁盘驱动调度

最佳次序执行，进行IO访问

#### 移臂调度

##### FCFS

性能糟糕

##### SSTF

最短寻道算法

饥饿问题：如果处于边缘位置，响应就比较慢

##### SCAN 扫描算法 

单向扫描

双向扫描，效率对比单向扫描更好一些

局限性：IO请求得随机性，可能前面已经没有了，扫描还是要继续，非常死板。

##### 电梯调度

对双向扫描的改进，移动方向没有访问请求的时候，换方向扫描

移臂调度的经典方案

可能出现，对比较远的地方，因为近的地方频繁访问而总是得不到资源。

可以通过限制一趟当中可以访问的最多次数，能够解决这个问题。减少运动时的黏性周期（分步扫描）扫描和先来先服务的一种结合。

#### 旋转调度

同一个柱面下的访问

把所有这个柱面的请求一起做好

目的是减少旋转延迟

优化IO请求，更好的排序

##### 循环排序

在最少旋转圈数内完成同一柱面的访问

##### 优化分布

磁头读取消耗的时间/读取之后处理的时间。电机通电之后以恒定的角速度旋转，因此最好第一个处理完之后下一个正好在磁头下方，节约时间。

通过调整信息的排列方式减少旋转延迟

###### 交替排序

可能读一个扇区并处理完，下一个扇区已经被跳过。通过计算，间隔得放在各个扇区里面。

正好让处理时间等于移动的时间。

所有数据集中在同一个柱面。

### 磁盘逻辑阵列 RAID

#### RAID 0

无备份

#### RAID 1

镜像备份

成本高，容量下降一半。

#### RAID 2

**海明码**教校验

适合大量顺序数据访问

多个冗余盘，成本较低。

#### RAID 3

交错位

RAID 2 的简化版，只用一个冗余

#### RAID 4

块奇偶校验

数据交叉存放

#### RAID 5

块分布奇偶校验

类似RAID 4，但是奇偶校验码交错存放

用的比较多

#### RAID 6

双重冗余

## Spooling系统

虚拟设备技术

用一类物理设备模拟另一类物理设备

比如内存模拟磁盘（高速磁盘），操作系统的关键文件

块设备模拟字符设备

设备管理被纳入文件系统当中。

输入输出重定向，输出到文件中，作为虚拟设备

可以通过虚拟化，将独占式的设备虚拟成为共享的设备。

#### 经典SPOOLing系统

基本的思想：预输入和缓输出，实现设备和进程间的松耦合。

通过磁盘存储空间来模拟输入输出设备

高速磁盘模拟慢速字符，缩短进程在内存的驻留时间。

先到输入井、输出井（磁盘环境）

所有的IO都基于磁盘，而不直接与慢速的IO设备交互。类似输入输出重定向，不过是通过操作系统直接管理。

##### 实现

预输入程序：输入到输入井

缓输出程序输出井到输出设备

井管理：IO重定向，两个井的管理、调用。

运行作业只和磁盘进行交互，与输出程序进行的是缓输出程序

周转时间、吞吐量

#### 打印SPOOLing系统

打印机守护进程是唯一可以打印集的设备

用户进程把需要打印的放到打印目录中。

## 批处理系统

作业的四个状态：输入、后备、执行、完成

SPOOLing控制预输入

后备状态具有构成变成进程，通过作业调度进程选择

执行状态，作业调度通过井管理程序，和输入输出井打交道。

完成状态，缓输出程序控制完成状态的进程。

作业说明语言，描述作业的加工处理步骤和方式。

作业说明书，与代码共同提交

作业状态

后备状态进入运行状态的前提是资源满足，和进程调度的区别。进程调度的时候是假设资源满足的。

资源满足之后，进行作业调度。





挂起的目的就是平滑性能，让进程离开三态模型，其实是释放了内存和设备资源。挂起本身就是资源紧张的情况。设备满足，内存不满足，挂起的时候其实是释放设备资源，防止他占用设备而不能运行，违反了挂起的初衷。挂起的时候设备同样也是释放的。从效果上来说，挂起和在输入井是一样的。解挂的条件还是内存和设备资源同时满足。实际上系统，使用虚存的条件下，不大可能出现内存不足的状况。

能满足还是满足

