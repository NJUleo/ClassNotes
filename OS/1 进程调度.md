## 进程调度

本来不直接支持多线程

提高进程并发的力度。

##### 早期：用户态多线程

起初内核层面没有多线程，当作单线程。设计时，内核不参与多线程行为——用户多线程

阻塞式系统改造成非阻塞式

接合三状态转换模型

在就绪态等待

内核调度时，不能把cpu分配到某个线程，因为不掌握进程中的线程

分两步，先分配进程，再在用户空间调度线程。

进程和线程的区别

单线程结构的进程

1. 资源分配单位
2. 处理器调度单位（执行流）

改造成多线程时候要分开，1归进程，2归线程。不过最终还是落到线程。

不管什么类型的多线程，**进程**一直是作为**资源分配单位**。

线程不是独立的存在，而是隶属于某一个进程，通过进程获取（除了处理器资源）资源分配。

###### 缺点

没办法实现物理上的并行

每个进程最多分一个处理器

要从内核层面支持线程

##### 内核级线程

内核直接管理每个进程的线程

内核知道每个线程的状态

线程也有状态转换模型，处理器调度时直接分配到某个进程的某个就绪线程

某个进程的多个线程可以在多处理器并行，实现物理上的真正并行，提高效率

###### 缺点

增加系统开销，如同一进程的线程间切换

##### 线程混合式策略

Solaris多线程技术

用户线程映射到内核线程，最多获得内核线程个数的处理器

内核线程再调度处理器

一个用户进程的多个线程可映射到不同数量的内核线程

同一进程内的多个线程的映射可以有一些是单独映射（不存在共享的调度）到内核线程



## 处理器调度

多线程并发、多道程序设计的前提

提高CPU利用率

闲下来就考虑从从就绪态中选中

#### 处理器调度的层次

狭义的处理器调度就是低级调度

队列数据结构管理

##### 低级调度

主要是就绪态和运行态

从就绪队列选进程

##### 中级调度

Swap

和等待态就绪态相关。挂起就绪，挂起等待

腾挪出内存空间，挂起进程，暂时不能获取资源。让就绪队列和等待队列进程的总数减少，在资源紧张的情况下优先考虑优先级高的进程。

缓冲池。就绪态等待态比较少的时候把一些挂起程序解挂。

被挂起的进程根本不在内存，没有办法运行。

##### 高级调度

是否接收链接

是否构建进程

是否加入就绪进程

处在最外围，本质上是作业调度

早期，多终端连接同一个计算机，将自己的程序交给主机管理员统一管理。根据系统资源，决定作业是否创建进程。甚至有时候提前退出。

### 处理器调度算法

#### 原则

资源利用率：提高系统性能，并行能力，多道程序设计的根本

响应时间：交互式场景

周转时间：进程从进入系统开始到结束所花的时间。考虑平均周转时间、归一化周转时间（除以实际使用CPU时间）

吞吐率：单位时间内处理的进程数。

公平性：整体性能和公平性。不能某些进程长时间等待。

#### FCFS

先来先服务，非抢占式

简单但是效率低下，短进程卡在长进程后面

#### 优先数调度算法

根据优先数决定运行进程

##### 抢占式

##### 非抢占式

##### 有限数确定准则

常作业不利

计算时间

响应时间：

​	响应比：等待时间/进入时间

先来先服务：非抢占式。常用于高级调度；若低级调度中，计算为主的就更优越，一旦获得CPU就长时间占据。高级调度不直接调度CPU资源。

###### 局限

要预先知道进程需要的CPU时长，事实上是难以预测的。

##### SRT

抢占式调度：有新进程到达时看当前进程是否优先

最短剩余时间调度

##### HRRN

Highest Response Ratio Next

最高响应比时间

（等待时间 + 期待服务时间）/ 期待服务时间

动态的优先级，兼顾公平性

非抢占式

#### 时间片轮转调度算法

超过时间片就让出资源

问题：如何确定时间片的长短？

太短，调度开销大，太长就是先来先服务

可以动态改变时间片

队列：新到达的进程先到等待队列排队

对短进程有利

###### 优点

无须预先知道运行时间

###### 问题

没有体现优先级

当前面有长进程排队轮转时，新来的进程还是需要排队。新进程没有办法优先

###### 解决

多级队列（多级反馈）



#### 多级反馈调度算法

惩罚机制

进程运行完时间片却没有完成任务（被抢占而进入），下次进入就绪队列时转入下一级的就绪队列。

综合方案，每一个RQ是时间片轮转，同时在不同队列是优先级。

容易延长短进程等待时间，造成吞吐率降低。

时间片是内核和用户的协议，在时间片中不会发生抢占，自己做阻塞不管。

###### 优点

解决了开始不知道进程的运行时间的问题，不需要预估程序的运行时间。（时间片轮转也）

直接跑来看到底时间长短。是骡子是马拉出来溜溜

###### 问题

对需要CPU计算时间长的进程不利，优先级不断下降。

###### 解决

让低优先级队列的时间片更长。

实际上本质是然时间短的程序早点算完，对时间长的进程，很难得到CPU资源，时间片更长，兼顾公平性.

###### 结果

偏袒：先到达、时间短的进程

提高单位时间系统吞吐量。

降低归一化周转时间： 周转时间 / CPU服务时长。

短的进程等得更短

对于程序自限的情况，它直接到等待队列当中。有时候等待序列进就绪队列也是最高优先级



## 批处理作业管理

脱机方式（提高自动化）

作业控制块JCP

高级调度

##### 作业状态

1. 输入状态：从输入设备上预输入信息。
2. 后备状态：玉树如结果但没有被选中执行
3. 执行状态：创建为进程，在进程状态转换模型中轮转。作业调度不管是否实际获取CPU时间
   * 进程调度
   * 要分清进程调度和作业调度算法的区别
4. 完成状态：

输出使用缓冲机制，降低系统耦合。先放到缓冲区

批处理作子进程的PC与执行完fork的位置相同, 连续fork()创建了一个子进程树

立场：自己作业的周转时间小

系统立场：平均作业周转时间小。归一化平均周转时间。

博弈

fork()创建子进程

子进程的PC与执行完fork的位置相同, 连续fork()创建了一个子进程树

























