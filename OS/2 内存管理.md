# 内存管理

多道程序设计的环境下，多个进程共享内存

不同进程的存储区域分割开，否则出现进程间的不安全性

- 动态/静态分区 分页/分段
  - 局限性：进程的空间受限5
  - 简单分页：资源的静态分配，内存的利用率降低
  - 动态分配？ -> 虚拟内存
- 虚存抽象
  - 虚拟段页式
  - 虚拟分段
  - 虚拟分页

### 段式程序设计

段覆盖技术：现代操作系统管理的统一，现在不太需要考虑。古代操作系统内存管理不行。

##### 逻辑地址

用户编程使用的地址空间

##### 物理地址

绝对地址，程序实际使用的地址

分区复用



#### 内存碎片

###### 内部碎片

已分配区域的内部。

进程运行中，分配给他，没有使用的空间不能被再分配

分页时也有这个问题，末尾的页也可能出现空余，再页的内部形成内部碎片

###### 外部碎片

已分配区域的外面。

##### 内存分配的原则

1. 同一个分区最多一个进程
2. 进程需要完全连续的空间。容器容量大于等于进程需求

##### 固定分区

产生内部碎片

程序没有使用完所有分配的分区。分配的固定分区不可避免得大于所需的空间

##### 动态分区

动态分配的过程中，某个进程退出之后，新的进程呢村使用了原来这个进程的位置内存，却没有用完，有一部分空间碎片没有被分配。

即使按照需求分配，也会产生外部碎片

多道程序设计下，频繁的进程加载退出，会产生大量的外部碎片。

外部碎片越小，越不容易再被分配

最后造成大量内存空间散落在内存中，导致大内存需求的进程无法被加载

进程移动，可能造成风险，并提高系统负担

#### 地址转换

逻辑地址转换为绝对地址（物理地址空间）。

##### 静态重定位

无法实行虚拟内存技术。由装入程序进行

##### 动态重定位

运行时确定地址。

通过硬件地址转换机构，高效的冲定位计算

某个逻辑地址，运行时在哪个物理地址在实现时无法知道的。

物理上页框进进出出，重复使用。

#### 主存储器空间的分配与去配

MMU内存管理单元

设计相应数据结构管理。

##### 分配

到底应该把程序加载在哪，装入主存。

##### 去配

归还主存资源。

#### 主存储器空间的保护和共享

##### 存储保护

判断是否跃界，产生中断

私有空间、公共空间等

##### 存储共享

多个进程共享某个区域协作完成任务时，考虑存储共享

带来“读者/写者问题”

共享存储区域准许多个读进程；有进程在读就不准许写；有写的就不准许读/写

并发进程的轨迹交叉不确定性可能造成结果不唯一

#### 主存储器空间的扩充

##### 主存扩充

1. 对换技术：进程转换模型中加入两个挂起态。不运行的进程调出。中间层次调度就绪态和等待态，系统资源紧张时把不紧急的进程挂起转到主存，暂时不能使用CPU。平滑系统性能。资源不太紧张的时候，解挂。

2. 虚存技术：压缩某一个进程的实际物理内存的大小，节省开销，提高利用率。

   进程比较少的时候，多加载进程提高利用率。提高到一定程度的时候，更多的进程并不会提高利用率。太多的时候实际上可以做挂起，减少进程道数。物理内存非常宝贵，使用虚存能够节省物理内存开销。部分装入，部分对换。进程的运行并不需要所有的部分，事实上大多数情况只需要邻近的部分，缺页时产生中断处理。

##### 软硬件协作

### 虚拟存储器

辅存虚拟地址空间

主存实际地址空间

地址空间扩展技术，对用户变成透明

降低进程加载的开销，减少物理内存实际分配，根据运行需要加载新的存储单元。

以页为单位调入调出。（一般4096字节）以页的尺寸做吞吐。和磁盘扇区做匹配

页内地址，页框内地址连续，只需要做，页地址到页框地址的映射

缺页中断，陷入内核，产生系统开销，调取缺少的页。同时要查看分配的页框是否满了，如果不能增加页框还要考虑页的替换。页框中的数据还要写回磁盘，为下一次使用保证数据一致性。

###### 利空

延长进程的运行周期

###### 利好

空间时间局部性，如顺序循环

有一个周期内集中访问一些页的集合，如果已经加入物理页框，那么缺页频次就不太高

通过页替换算法减少缺页。

从个体的角度考虑，时间拉长并不多；从系统考虑，整体性能大大提升，因为内存的利用率高，进程道数提升（一定范围内性能提升）

##### 虚存的好处

虚拟地址空间的大小和物理内存容量无关。本质上就是物理内存资源实现运行时动态分配。扩大程序员可以使用的地址空间，不需要考虑物理内存够不够用。

虚地址的大小和字长有关，32位就是2 ^ 32，4 GB。

页的加载对程序员透明，屏蔽底层细节。自动化实现。早期程序员还要考虑段的置换。

### 存储管理的硬件支撑

存储管理对象：主要时管理主存

##### Cache

减少访存，最低Cache在CPU，不经过总线 

高速小容量

SRAM

快于主存，

#### 高速缓存存储器

地址寻址

地址转换部件

高速存储时，需要从内容寻址。联想存储器

#### 分级

很多情况下，总线改善比L3 Cache更好

总线通信带宽成为瓶颈

#### 硬件支撑

基址寄存器记录进程起始地址

限长寄存器，判断越界，产生中断

动态重定位和存储保护需要硬件支撑

虚拟存储器也需要硬件支撑

软件实现的效率太低。



### 可变分区管理

一开始并不定义总共的分区和分区的长度，只是把所有可用的放在整体对待

对进程到达时实际的需要分配（也因此外部碎片）

回收的时候将连续的分区进行合并。



#### 分配算法

内存去的重新调整

可变分区管理的一大问题就是外部碎片

动态重定位

##### first fit 最先适应分配算法

顺序查找未分配区表，到第一个能够被装入空闲区的，将它装入。通常分配的时候优先分配小地址的，这样尽量保持一个大的空闲区与在高地址区。

###### 问题

内存两端使用不均衡

回收分区麻烦，要查找位置

##### Next Fit邻近适应分配算法

从未分配区上次扫描到的位置找第一个满足的。

减少平均查找时间，利用率更均衡，同时也是同样的原因，没有把小空闲区放在一端

##### Best Fit最优适应分配

最小的可容纳的。

扫描整个未分配区表，时间最长

对大作业装入友好

容易造成非常小的外部碎片（某种意义上说，既是优点也是缺点，优点再与内存利用率似乎更高，缺点在于，这些小碎片难以利用）

##### Worst Fit最坏适应

装入最大的分区。

对中小型作业有利

通过把空闲分区表按照从大到小的顺序排列，其查找速度很高，和First Fit速度一样。



##### 移动技术（程序浮动技术）

把小的空闲区挪到一起



### 页面替换算法

全局序列，不限定窗口长度

OPT FIFO LRU CLOCK

大的趋势上，页框增加，缺页。

大体上，算法得成本：FIFO CLOCK LRU OPT

##### 产生的背景

引入虚存，分页存储管理，必然遇到的问题：运行中，随着寻址范围的扩大，加载页到页框直到填满，一旦发生缺页，就要将已经在页框中的页替换，同时要考虑读写操作，发生写操作，就要将被替换页重新写入，增加了磁盘IO。

##### OPT

Belady算法

“预测未来”，把未来不大可能调度的进行替换。

根据之后要访问的来进行。实际上是无法实现的

页号通过寻址的时候，根据逻辑地址规格移位操作，获得页号。

（例子中，F表示缺页）

##### FIFO

很多调度上，都会考虑这种队列的思想。

一般朴素的排队性能都不会太好。

局限性：本身不考察历史页面中的规律，比如周期性。完全按照时间，容易造成循环的时候，重复缺页。

###### Belady异常

页框增加，反而更加缺页

在局部情况下，反常得增多缺页。（总体上来说，还是随着页框增加而下降）

教材P 225

FIFO算法得异常

##### LRU

OPT对未来得预测无法实现，那么就考虑过去。

想法是，通过过去预测未来。

替换最近最少使用。

把最远的页替换

实现时候需要配合硬件设施，成本比较高。近似使用LFU

##### CLOCK

系统实现比LRU容易一些。

有一个表盘，序号表示页框，并不一定连续

两个信息：当前指针指向的页框（哪个页），每个页的使用位

新加进来的页使用位为1，比FIFO算法读一次被扫描的机会

如果发生命中，指针不波动

指针的波动是寻找可被替换的页。

如果发生命中，被命中页的使用位变1。

CLOCK算法捕捉程序运行中可能存在的循环

发生替换的时候，波动，寻找被替换的对象。

寻找指针扫描的第一个使用位为0的，被替换。被扫过的使用位改为0。

完成替换之后，指针++（下一轮替换的起点）

本质上，虽然很早就进来，但是最近使用过，所以不先替换。

总体来说，就是每一个页多一条命，改善循环问题

### 驻留集

实际的页框的集合和页内的集合

大小是页框数量的规模。

设计的时候，一种固定数量页框，另一种是分配可变页框数。

可变分配更规律一些。

替换时，局部替换或全局替换。

###### 固定页框数是一般局部替换，不会抢占

###### 可变分配，可以是全局替换

操作系统内核预留一部分灵活的页框，实时的为一些进程补充一些

### 局部页面替换算法

观察的窗口长度是局部的。

实际上，考虑算法步长。

驻留集，已经加入页框的页

##### 局部最佳替换算法

##### 工作集模型和工作集置换算法

局部性原理、工作集调度

观测程序局部性周期的数学方法

工作集：一段时间间隔内，进程运行所需访问的页面的集合。

对局部最佳页面算法的模拟。

由于无法预知未来，只能统计过去。

考虑过去一段时间内的页集合（这段时间是工作集的尺寸）

通过过去一段时间的主存需求，作出估计。

任何预测都是无法避免错犯，只能尽可能提高预测。

根据工作集的大小，配置页框数。实时调整给进程分配的页框数

在优先步长内选择可以看到的页，进行页的替换。

工作集的大小会随着命中率调整。

当频繁命中时，工作集就比较小，连续访问同一个页，最后工作集就只有一个页。

工作集的规模，在随着全局不断发生调整，基本上时陡变和平稳的交替

不同平稳周期，工作集的规模不一样。

为进程分配页框时，尽可能符合工作集的尺寸，来节约内存，同时保证命中率，配置合理的页框数让页面替换算法能更好的跟随局部性周期的变化。

陡变周期相对而言比较小。

在陡变期，页面替换算法难以发挥很好的作用，不过通过工作集的变动，进入平缓期之后就比较好一些。

进程的道数适度增加，CPU利用率提升，再提升的时候，又下降，CPU忙于内核工作

页框太少，缺页，页框过大，浪费

### 多级页表和反置页表

出发点：减少页表的内存开销。

如果对每个进程都是独立私有的页表，则其存储开销太大。

使用虚存思想的时连续连续连续连续候，用户进程能够寻址的范围巨大，不受限于物理内存，而是字长决定。

##### 多级页表

将逻辑地址再做分割。页目录号、页号、页内偏移量

内存中只存入页目录表。同时有快表

两级寻址

##### 反置页表

同样时页号到页框号

在虚拟分页中，每个进程的单独页表，正向页表，各个页无论是否加载在页框都会产生页表的存储开销。

反置页表，通过物理页框来进行记录，可能节省页表存储开销

页表大小只跟页框的尺寸有关。

正向页表的页号是隐式存在的，由于连续排列、各进程分开，只要设定总入口，则向下的偏移就能够定位到页号。页号作为隐藏的进行查找

对于反置页表，所有进程的页表放在一起。有一个总入口。

不包含页框号，但包含页号和进程ID。

反置页表，按照页框号排列。通过遍历，查找页框号

实际上是时间换空间。

为了提高效率，引入哈希函数，页表项增加指针，跳转

通过哈希函数，入口由哈希函数计算

反置页表的规模和页框数量相关，节省页表项的内存开销。



**P 211 - 213**

##### 正向页表

各进程分开

哪个在运行，页表起始地址放到页表基址寄存器中。

无论页是否被加载，都会产生页表项，造成浪费

索引代表页号

##### 反置页表

各个进程的页表项混合在一起

索引代表页框号

##### 哈希线性反置页表

哈希函数

例如，把进程id相同的，用指针串起来

通过哈希链连起来

##### 总结

寻址性能比简单正向页表差，增加额外IO操作、多次访存。

本质上是用时间换空间。

增加哈希结构，就是在反置页表基础上，用空间换时间。

##### 主存分配的位示图和链表方法

### 页的尺寸

页的尺寸和缺页率。

极大的时候，退化为固定分区

不可太小也不可太大往往根据经验

大部分是4 KB

## 段存储设计

段对程序员可见

本质上可以理解为可变分区管理上的扩展

分页可以理解为，大小相等的分区上的扩展

简单的可变分区，限定进程只能一个分区，现在扩展为，一个进程分多个分区。

逻辑上多个段

段的数量多，只能放在内存，段表

各个进程的段表分开，段表基址为运行进程的，放在寄存器，用于查找段表项

段内逻辑地址从0开始

段的共享

以段为单位

纯粹使用段存储，受限于断肠的不确定，性能不太好

以段为单位，进行对换，代价很大

每一个段是一个可变分区

## 段页存储设计

段存储，结合虚存工作时非常糟糕

在段内分页，提高灵活性

段程序设计基于页存储管理的存储模式

每一段不是连续可变空间，存放在不连续的页框中

扩充为虚拟存储

装入部分段的部分页

段表不再记录基址限长而是页的基址length（通过页来体现）

段表项中只需要记录页表基址和页表长

页表长是准许的页号的数量，限定了段准许的地址长度

总的来说，表存在就代表了装入内存，然后是虚存技术的考虑（缺页）

## 总结

高级调度是从作业到进程的过程，主要判断系统资源是否足够（外设，不考虑内存是否足够），作业调度策略包括 FCFS（先来先服务） SJF（最短作业优先）

中级调度是考虑内存，将进程挂起（不占用内存）。主要算法有FCFS，SJF，HRRF， 

低级调度是就绪态、等待态、运行态之间的转化调度

## 作业题

3.1 

在11：00之前，所有作业按顺序等待调度。

11：00 根据作业进输入井顺序，依次选择是否进入就绪态，发现J1 J2都没问题，进入就绪态，同时内存足够，都装入主存，J3 到J5都是磁带机不足，保留在后备状态。主存剩余25K。

11：50 由于使用时间片轮转调度，就绪态的两个进程轮流使用CPU直到这个时刻，J1作业完成，J2剩余5分钟，此时内存剩余15K + 25K，磁带机剩余3台。此时，按3 4 5的顺序依次判断作业是否能够进入就绪态，J3的设备资源满足，但是主存不足，进入挂起就绪态，此时磁带机占用4太，J4 J5只能继续在后备状态等待。

11：55 J2完成，J3被装入主存，进入就绪态（运行态）。此时磁带机剩余1台，J4 J5仍然等待。

12：05 J3完成，内存和磁带机全部不被占用。依次判断J4 J5都同时满足内存和磁带机，同时装入主存，进入就绪态。



3.2

11:00之前，所有作业依次被输入，等待调度。

11：00 1-5作业的响应比依次为：2.4, 1.33, 3, 1.25, 1.33, 按照响应比优先的原则，首先将J3调入，内存占用50K，磁带机占用3，此时满足资源要求的作业只有J2，但是内存需求不满足，因此转入挂起就绪态，此时内存占用50K，磁带机占用4。

11：10  J3完成，此时J2内存需求满足，进入就绪态，内存占用60K，磁带机占用1。此时各作业响应比如下

| 作业名 | J1            | J4             | J5          |
| ------ | ------------- | -------------- | ----------- |
| 响应比 | 70 / 25 = 2.8 | 35 / 20 = 1.75 | 30 / 15 = 2 |

磁带机的要求都满足，按照响应比优先，将J1调度，内存也满足，因此进入就绪队列，此时磁带机剩余1,J4 J5都不满足。内存占用60K + 15K

12：00 J1完成，J2剩余5分钟，内存剩余40K，磁带机剩余3，此时响应比如下

 

| 作业名 | J4             | J5             |
| ------ | -------------- | -------------- |
| 响应比 | 85 / 20 = 4.25 | 80 / 15 = 5.33 |

J5响应比最高，被调度，内存足够，进入就绪队列。

12：10 J2完成，J5剩余10分钟，内存剩余60K + 10K，磁带机剩余2台，J4全部要求满足，进入就绪队列。

4 

First-Fit 装入第一个满足的空闲分区中。

初始内存空闲分区状态：100	500	200	300	600

| 装入用户进程大小 | 装入分区           | 内存空闲区状态              |
| ---------------- | ------------------ | --------------------------- |
| 212K             | 第二个，500K       | 100， 288， 200， 300， 600 |
| 417K             | 第五个，600K       | 100， 288， 200， 300， 183 |
| 112K             | 第二个，288K       | 100， 176， 200， 300， 183 |
| 426K             | 内存不足，无法装入 |                             |

Best-Fit 装入能够满足的最小分区中

初始内存空闲分区状态：100	500	200	300	600

| 装入用户进程大小 | 装入分区      | 内存空闲区状态             |
| ---------------- | ------------- | -------------------------- |
| 212K             | 第四个，300K  | 100， 500， 200， 88， 600 |
| 417K             | 第二个，500K  | 100， 83， 200， 88， 600  |
| 112K             | 第三个， 200K | 100， 83， 88， 88， 600   |
| 426K             | 第五个，600K  | 100， 83， 88， 88， 174   |

Worst-Fit 装入最大分区中

初始内存空闲分区状态：100	500	200	300	600

| 装入用户进程大小 | 装入分区           | 内存空闲区状态              |
| ---------------- | ------------------ | --------------------------- |
| 212K             | 第五个，600K       | 100， 500， 200， 300， 388 |
| 417K             | 第二个，500K       | 100， 83， 200， 300， 388  |
| 112K             | 第五个，388K       | 100， 83， 200， 300， 276  |
| 426K             | 内存不足，无法装入 |                             |

5

| 访问页   | A    | B    | C    | D    | A    | B    | E    | A    | B    | C    | D    | E    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 页框1    | A    | A    | A    | D    | D    | D    | E    | E    | E    | E    | E    | E    |
| 页框2    |      | B    | B    | B    | A    | A    | A    | A    | A    | C    | C    | C    |
| 页框3    |      |      | C    | C    | C    | B    | B    | B    | B    | B    | D    | D    |
| 缺页异常 | Y    | Y    | Y    | Y    | Y    | Y    | Y    | N    | N    | Y    | Y    | N    |
| 淘汰页框 |      |      |      | 1    | 2    | 3    | 1    |      |      | 2    | 3    |      |

总共发生的页面替换次数是6（如果认为前三次，加载到空的页框也算的话，也就是缺页异常次数，则是9）

| 访问页   | A    | B    | C    | D    | A    | B    | E    | A    | B    | C    | D    | E    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 页框1    | A    | A    | A    | A    | A    | A    | E    | E    | E    | E    | D    | D    |
| 页框2    |      | B    | B    | B    | B    | B    | B    | A    | A    | A    | A    | E    |
| 页框3    |      |      | C    | C    | C    | C    | C    | C    | B    | B    | B    | B    |
| 页框4    |      |      |      | D    | D    | D    | D    | D    | D    | C    | C    | C    |
| 缺页异常 | Y    | Y    | Y    | Y    | N    | N    | Y    | Y    | Y    | Y    | Y    | Y    |
| 淘汰页框 |      |      |      |      |      |      | 1    | 2    | 3    | 4    | 1    | 2    |

页面替换次数是6（缺页异常次数是10）

注：这就是melody异常，个人认为是主要发生在一个循环的大小恰好比页框数量多1的时候，导致之后每次循环都完全没有命中。



7

（1）OPT 选择之后最晚被访问的页进行替换（理想的算法）

| 访问页   | 1    | 2    | 3    | 1    | 4    | 5     | 1    | 2    | 1    | 4    | 5    | 3     | 4    | 5    |
| -------- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- |
| 页框1    | 1    | 1    | 1    | 1    | 1    | 1     | 1    | 1    | 1    | 1    | 1    | **3** | 3    | 3    |
| 页框2    |      | 2    | 2    | 2    | 2    | 2     | 2    | 2    | 2    | 2    | 2    | 2     | 2    | 2    |
| 页框3    |      |      | 3    | 3    | 3    | **5** | 5    | 5    | 5    | 5    | 5    | 5     | 5    | 5    |
| 页框4    |      |      |      |      | 4    | 4     | 4    | 4    | 4    | 4    | 4    | 4     | 4    | 4    |
| 缺页异常 | Y    | Y    | Y    | N    | Y    | Y     | N    | N    | N    | N    | N    | Y     | N    | N    |
| 淘汰页框 |      |      |      |      |      | 3     |      |      |      |      |      | 1     |      |      |

（2）FIFO 选在最早加载的页淘汰。

| 访问页   | 1    | 2    | 3    | 1    | 4    | 5     | 1     | 2     | 1    | 4    | 5    | 3     | 4     | 5     |
| -------- | ---- | ---- | ---- | ---- | ---- | ----- | ----- | ----- | ---- | ---- | ---- | ----- | ----- | ----- |
| 页框1    | 1    | 1    | 1    | 1    | 1    | **5** | 5     | 5     | 5    | 5    | 5    | 5     | **4** | 4     |
| 页框2    |      | 2    | 2    | 2    | 2    | 2     | **1** | 1     | 1    | 1    | 1    | 1     | 1     | **5** |
| 页框3    |      |      | 3    | 3    | 3    | 3     | 3     | **2** | 2    | 2    | 2    | 2     | 2     | 2     |
| 页框4    |      |      |      |      | 4    | 4     | 4     | 4     | 4    | 4    | 4    | **3** | 3     | 3     |
| 缺页异常 | Y    | Y    | Y    | N    | Y    | Y     | Y     | Y     | N    | N    | N    | Y     | Y     | Y     |
| 淘汰页框 |      |      |      |      |      | 1     | 2     | 3     |      |      |      | 4     | 1     | 2     |

(3) SCR 第二次机会算法 每个页进入主存之后引用为为1，访问过后的引用位也置1，如果被选中淘汰而引用位为1，则只把它置0然后考虑下一个页。如果全0，退化为FIFO算法。

引用位为1的用*标出。和普通的CLOCK是一致的，只不过实现上是队列，CLOCK是循环链表。

| 访问页   | 1    | 2    | 3    | 1    | 4    | 5    | 1    | 2    | 1    | 4    | 5    | 3    | 4    | 5    |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 页框1    | 1*   | 1*   | 1*   | 1*   | 1*   | 5*   | 5*   | 5*   | 5*   | 5*   | 5*   | 5    | 4*   | 4*   |
| 页框2    |      | 2*   | 2*   | 2*   | 2*   | 2    | 1*   | 1*   | 1*   | 1*   | 1*   | 1    | 1    | 5*   |
| 页框3    |      |      | 3*   | 3*   | 3*   | 3    | 3    | 2*   | 2*   | 2*   | 2*   | 2    | 2    | 2    |
| 页框4    |      |      |      |      | 4*   | 4    | 4    | 4    | 4    | 4*   | 4*   | 3*   | 3*   | 3*   |
| 缺页异常 | Y    | Y    | Y    | N    | Y    | Y    | Y    | Y    | N    | N    | N    | Y    | Y    | Y    |
| 淘汰页框 |      |      |      |      |      | 1    | 2    | 3    |      |      |      | 4    | 1    | 2    |

注：页5第一次加载的时候，从最早加载的页框（1）开始，扫到4，把他们的引用位全部置0，然后再回到1，进行替换。下一次缺页从2开始。



（4）改进的CLOCK 

除了引用，还考虑修改

第一次循环不改变引用位，找到第一个未引用未修改的替换。（0，0的最优先）

第二次循环改变引用位，查找第一个引用位0，修改位1的进行替换（0，0不存在，找到第一个0，1）

第三次循环，（找到1，*）

这里用*标记引用位，$标记修改位

| 访问页   | 1    | 2    | 3    | 1    | 4    | 5      | 1      | 2    | 1    | 4    | 5    | 3      | 4      | 5      |
| -------- | ---- | ---- | ---- | ---- | ---- | ------ | ------ | ---- | ---- | ---- | ---- | ------ | ------ | ------ |
| 页框1    | 1*   | 1*   | 1*   | 1*   | 1*   | **5*** | 5*     | 5*   | 5*   | 5*   | 5*   | 5      | **4*** | 4*     |
| 页框2    |      | 2*$  | 2*$  | 2*$  | 2*$  | 2$     | 2$     | 2*$  | 2*$  | 2*$  | 2*$  | 2$     | 2$     | 2$     |
| 页框3    |      |      | 3*   | 3*   | 3*   | 3      | **1*** | 1*   | 1*   | 1*   | 1*   | 1      | 1      | **5*** |
| 页框4    |      |      |      |      | 4*   | 4      | 4      | 4    | 4    | 4*   | 4*   | **3*** | 3*     | 3*     |
| 缺页异常 | Y    | Y    | Y    | N    | Y    | Y      | Y      | N    | N    | N    | N    | Y      | Y      | Y      |
| 淘汰页框 |      |      |      |      |      | 1      | 3      |      |      |      |      | 4      | 1      | 3      |



（5） LRU 最近最没有被用的，是将OPT的思路做一个反转

| 访问页   | 1    | 2    | 3    | 1    | 4    | 5     | 1    | 2     | 1    | 4    | 5    | 3     | 4    | 5    |
| -------- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ----- | ---- | ---- | ---- | ----- | ---- | ---- |
| 页框1    | 1    | 1    | 1    | 1    | 1    | 1     | 1    | 1     | 1    | 1    | 1    | 1     | 1    | 1    |
| 页框2    |      | 2    | 2    | 2    | 2    | **5** | 5    | 5     | 5    | 5    | 5    | 5     | 5    | 5    |
| 页框3    |      |      | 3    | 3    | 3    | 3     | 3    | **2** | 2    | 2    | 2    | **3** | 3    | 3    |
| 页框4    |      |      |      |      | 4    | 4     | 4    | 4     | 4    | 4    | 4    | 4     | 4    | 4    |
| 缺页异常 | Y    | Y    | Y    | N    | Y    | Y     | N    | Y     | N    | N    | N    | Y     | N    | N    |
| 淘汰页框 |      |      |      |      |      | 2     |      | 3     |      |      |      | 3     |      |      |



(6) MIN

局部最佳页面替换算法，每次把（t, t + T)中不存在的移除驻留集，T = 3
| 时刻   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 引用串 | 1    | 2    | 3    | 1    | 4    | 5    | 1    | 2    | 1    | 4    | 5    | 3    | 4    | 5    |
| P1     | Y    | Y    | Y    | Y    | Y    | Y    | Y    | Y    | Y    |      |      |      |      |      |
| P2     |      | Y    |      |      |      |      |      | Y    |      |      |      |      |      |      |
| P3     |      |      | Y    |      |      |      |      |      |      |      |      | Y    |      |      |
| P4     |      |      |      |      | Y    |      |      |      |      | Y    | Y    | Y    | Y    |      |
| P5     |      |      |      |      |      | Y    |      |      |      |      | Y    | Y    | Y    | Y    |
| In     | P1   | P2   | P3   |      | P4   |      |      | P2   |      | P4   | P5   | P3   |      |      |
| Out    |      |      | P2   | P3   |      | P4   | P5   |      | P2   | P1   |      |      | P3   | P4   |



（7）WS（t-T, T）中不存在的移除驻留集 T = 3

| 时刻   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 引用串 | 1    | 2    | 3    | 1    | 4    | 5    | 1    | 2    | 1    | 4    | 5    | 3    | 4    | 5    |
| P1     | Y    | Y    | Y    | Y    | Y    | Y    | Y    | Y    | Y    | Y    | Y    | Y    |      |      |
| P2     |      | Y    | Y    | Y    | Y    |      |      | Y    | Y    | Y    | Y    |      |      |      |
| P3     |      |      | Y    | Y    | Y    | Y    |      |      |      |      |      | Y    | Y    | Y    |
| P4     |      |      |      |      | Y    | Y    | Y    | Y    |      | Y    | Y    | Y    | Y    | Y    |
| P5     |      |      |      |      |      | Y    | Y    | Y    | Y    |      | Y    | Y    | Y    | Y    |
| In     | P1   | P2   | P3   |      | P4   |      |      | P2   |      | P4   | P5   | P3   |      |      |
| Out    |      |      |      |      |      | P2   | P3   |      | P4   | P5   |      | P2   | P1   |      |





2. 

| 作业名 | 开始执行时间 | 执行结束时间 | 周转时间 |
| ------ | ------------ | ------------ | -------- |
| J1     | 8：00        | 8：25        | 25       |
| J2     | 9：05        | 9：15        | 55       |
| J3     | 8：25        | 8：45        | 25       |
| J4     | 8：45        | 9：05        | 35       |
| J5     | 9：15        | 9：30        | 55       |

8：00	J1被创建为进程，进入就绪态而直接到运行态，在CPU中执行。内存剩余85K，磁带机剩余1，打印机剩余0

8：20	J2 J3进入输入井，J2由与打印机不足，在后备队列中等待。J3的内存和外设资源都满足，被创建进程，进入就绪队列。内存剩余25K，磁带机剩余0，打印机剩余0

8：25	J1运行完毕，释放资源，内存剩余15K + 25K，磁带机剩余1，打印机剩余1，此时后备队列中的J2的内存需求扔不能满足，继续在后备队列等待。J3进入运行态，在CPU运行。内存剩余15K + 25K，磁带机剩余1，打印机剩余1

8：30 	J4进入输入井，其内存和外设需求都被满足，被创建为进程，进入就绪队列，它将占用内存25K的空闲区的前20K。此时内存剩余15K + 5K，磁带机剩余0，打印机剩余1。

8：35	J5进入输入井，内存和外设需求都不满足，在后备队列中等待。内存剩余15K + 5K，磁带机剩余0，打印机剩余1

8：45	J3运行完毕，释放资源，内存剩余75K + 5K，磁带机剩余1，打印机剩余1，J4进入运行态运行，此时，后备队列依次是J2 J5，发现J2的内存和外设都满足，进入就绪队列，内存剩余45K + 5K，磁带机剩余1，打印机剩余0，此时J5的外设不能被满足，继续等待。

9：05	J4运行完毕，J2进入运行态。此时J5的外设需求不被满足，继续等待。

9：15	J2运行完毕，J5进入就绪态然后直接进入运行态运行。

综上所述，

（1）先后次序为，J1 J3 J4 J2 J5

（2） 全部作业运行结束的时间是9：30

（3） 平均周转时间是(25 + 55 + 25 + 35 + 55) / 5 = 39mins

（4） 最大作业周转时间是55mins，是J2和J5





3

先来先服务

11：00	之前，所有作业在后备队列等待。

11：00	按照输入的顺序依次考察J1 - J5，J1满足，创建进程，J2满足，创建进程，内存剩余25K，磁带机剩余1，剩下三个都无法满足。根据时间片轮转算法，J1 J2轮流使用CPU。

11：50	J1执行完毕，J2剩余5mins。内存剩余15K + 25K, 磁带机剩余3。依次考虑后备队列，J3不能满足，J4满足条件，创建进程，内存剩余5K + 25K， 磁带机剩余1，然后J5无法满足。J4 J2轮流使用CPU

12：00	J2执行完毕，J4剩余15mins。内存剩余5K + 85K，磁带机剩余2。依次考察后备队列，J3外设不满足，J5全部满足，创建进程，内存剩余5K + 55K， 磁带机剩余0。

12：30 J4 J5同时运行完毕，J3被创建进程，加载进内存。



最高响应比优先

11：00之前所有作业在后备队列等待

11：00	响应比如下

| 作业名 | J1   | J2   | J3   | J4   | J5   |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 响应比 | 2.4  | 1.33 | 3    | 1.25 | 1.33 |

按照响应比从大到小优先的顺序，依次考虑作业。J3被创建进程，主存剩余50K，磁带机剩余1，然后所有其他作业都无法满足内存和外设需求，全部在在后备队列等待

11：10	J3运行完毕释放资源，各个作业响应比如下

| 作业名 | J1   | J2   | J4   | J5   |
| ------ | ---- | ---- | ---- | ---- |
| 响应比 | 2.8  | 1.67 | 1.75 | 2    |

按照响应比从大到小优先的顺序依次考虑，J1被创建进程，内存剩余85K，磁带机剩余2。J5被创建进程，内存剩余55K，磁带机剩余0，其他作业继续等待。

11：40	J5运行完毕，J1剩余10mins，各作业响应比如下

| 作业名 | J2   | J4   |
| ------ | ---- | ---- |
| 响应比 | 2.67 | 3.25 |

内存剩余85K，磁带机剩余2，J4被创建进程，内存剩余55K，磁带机剩余0。J2继续等待。

12：00	J1运行完毕，J4剩余10mins。内存剩余15K + 55K，J2的内存无法满足，继续等待。

12：10	J4运行完毕，J2创建进程。

