# 数据库

主要目标：高数据量、高并发

时间复杂度和空间复杂度的体现。在不同的要求下，同样的目的需要的软件是不同的。

### 开发成功数据库的要点

不要当成黑盒，要了解其体系结构和特征

常见的失败是对数据库的不了解

系统的核心是数据，存储的环境是数据库。

数据库体系结构的差异是巨大的。会大值

不同的DBMS有巨大的差异。

windows是进程/可执行程序多个线程

oracle的连接是重连接，MySQL是轻连接，需要更多的交互，不能浪费连接。

SS连接断掉运行没有问题，oracle上是不行的。

#### 并发控制的问题

并发控制让数据库不同于文件系统。

顺序情况下可能很好，同时进行可能出现问题。

不同数据库的并发机制不同，不了解的情况下没有办法做到好的结果，可能破坏数据完整性、速度慢、难以扩展支持更大量的数据库。

并发控制问题产生连锁反应。上下文切换。

复杂的原因在与，问题难以调试。

数据库通过锁机制处理并发。阻止同一行并发更新。不同的数据库系统锁机制不同，如果不了解可能会导致开发困难、错误。

oracle多版本控制、读一致性并发模型。

* 读一致性：一个时间点，查询产生一致结果。读到开始读的时间点的数据
* 非阻塞查询：查询不被写入阻塞。在其他数据库中可能不同。

打开游标的时候不复制数据，只在获取的时候读取数据。

delete命令将删除的数据放到undo数据区，叫做回滚段，游标在这个区域读取数据。

好处：大幅度提高吞吐量。

闪回特性，提供任何时间点的数据。

对于其他数据库，读的时候需要锁，写操作需要等待并回滚。

通过一致性读，大规模提高吞吐率，避免锁表——读共享锁。

考虑几千万行的写，导致这个表被锁住，导致数据库死锁。

oracle

* 只有修改时加锁
* 只读数据，绝对不会加锁
* 写不阻塞读
* 读写器不阻塞写入器

充分了解锁机制对数据库开发有巨大的帮助。数据库之间的差异巨大。

读一执行问题：如果需要保证最多只有一个用户访问一行数据，就需要开发人员做一些工作。恰恰因为非阻塞性读，导致这个问题。需要进行强制串行。

因此，把数据库当成黑盒是糟糕的。必须深入了解其体系结构

数据库debug非常困难。

#### 黑盒与数据库独立性

数据库有脱离实现级别的使用方法

完全数据库独立的应用且高可拓展是困难的

细微的差别（如对NULL）和基本结构的差别（并发控制）可能造成显著影响

#### 设计问题

设计决定性能的上限，技巧决定系统下限

性能指标：每秒钟处理多少事务。使用吞吐量指标

具体的一个单一提升可能导致另一个性能障碍，导致整体的吞吐量性能下降

整体性能优化考虑